<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计网</title>
      <link href="//69394d17.html"/>
      <url>//69394d17.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="http头部包含那些信息"><a href="#http头部包含那些信息" class="headerlink" title="http头部包含那些信息"></a>http头部包含那些信息</h3><p>http头部实质上是传递重要信息的键值对，包括通用头部、实体头部、响应头部和请求头部。</p><p>其中通用头部是浏览器和客户端都需要用到的信息，比如说时间头部。</p><p>实体头部是指请求的实体信息，比如说https在传递请求信息的时候，就是将这个信息封装在请求的实体之中的。</p><p>响应头部是指的浏览器端响应客户端的请求，做出的响应信息，比如响应我是哪种server服务器。</p><p>请求头部是指请求报文特有的，告诉服务器一些额外的信息，比如说我要接受那种类型的信息。</p><h3 id="Keep-alive-和-非keep-alive的区别"><a href="#Keep-alive-和-非keep-alive的区别" class="headerlink" title="Keep alive 和 非keep alive的区别"></a>Keep alive 和 非keep alive的区别</h3><p>keep alive是指一直客户端与服务器一直保持链接，进行消息的传递，一个客户端可以通过一个TCP链接像多个页面发送请求，多个服务器也可以通过一个TCP链接像一个客户端返回信息。而非keep alive指的是，当我处理完请求的时候，链接就断开了，当有下次请求的时候，重新建立TCP链接。keep alive的形式长期占用系统资源。非keep alive是早期的http1.0的形式，keep alive是http1.1的形式。</p><h3 id="Http长连接短链接使用场景"><a href="#Http长连接短链接使用场景" class="headerlink" title="Http长连接短链接使用场景"></a>Http长连接短链接使用场景</h3><p>Http长连接使用在用户量少，操作频繁，点对点的比如通讯、网络游戏等。</p><p>Http短链接使用在用户量大，比如淘宝、京东等电商平台，用户量大采用长连接会导致服务器大量资源被浪费。</p><p><strong>注：注意区分长连接和keep alive。长连接是在keep alivehttp1.1的基础上实现的。短链接也是在tcp的协议基础上实现的。也有三次握手。</strong></p><h3 id="http的报文长度"><a href="#http的报文长度" class="headerlink" title="http的报文长度"></a>http的报文长度</h3><p>http的报文长度如果有的话，就在响应信息中的content-length中，有一种就是动态加载，未知长度信息的情况，此时应该是使用的Transfer encoding：chunked，</p><p>分块传输编码（Transfer encoding：chunked）是http1.1新引入的一种协议，当传输的信息被分成块传输的时候，此时并不知道整块数据的大小，每一个分块都包括一个十六进制的长度值和数据，当传输块长度值为0的时候作为结束的编码，标识实体结束。</p><p>如果没有的话，就是没有。</p><h3 id="HTTP了解的方法有哪些"><a href="#HTTP了解的方法有哪些" class="headerlink" title="HTTP了解的方法有哪些"></a>HTTP了解的方法有哪些</h3><p>Http1.0开始时只包括三种方法，包括GET、POST和head方法。Http1.1的协议增加了patch delete trace put options 和connect的方法。</p><ul><li>GET：请求获取某个页面的信息，我们经常在测试的时候会用到GET。</li><li>POST：向服务器提交指定资源数据处理请求（说白了就是请求处理服务器中的数据，通常是以表单的形式上传文件），此时，通常会伴随着已有资源的更改或者资源的更新。</li><li>HEAD：head方法类似于get，只不过他请求的是head头部的信息。</li><li>DELETE：顾名思义，就是删除掉服务器中的指定资源。</li><li>TRACE：trace方法是返回客户端发送给服务器的数据，通常作为测试使用。</li><li>OPTIONS：返回的是客户端用于请求的方法。</li><li><strong>PATCH：是对PUT方法的补充，用于对局部资源的更新处理。</strong></li><li>CONNECT：connect方法是让服务器代理用户，让服务器代理用户进行访问</li></ul><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul><li>get请求发送数据的时候，需要将数据放在url后面，不安全，post是放在请求实体中，比较安全。</li><li><strong>get只支持url编码，而post支持多种编码。</strong></li><li>get只支持ASCII编码，而post没有限制。</li><li>get通常用于请求某个页面的信息，而post则是对服务器中某一资源的修改。</li><li>get通常是使用Request.QueryString来获取变量的，post则是使用Request.Form来获取的。</li><li>get发送的数据大小有限制，而post发送的数据没有限制。</li><li>get方法产生一个TCP数据包，而post产生两个TCP数据包。</li></ul><h3 id="GET的长度限制是多少"><a href="#GET的长度限制是多少" class="headerlink" title="GET的长度限制是多少"></a>GET的长度限制是多少</h3><p>GET 和 POST<br>get 将参数直接写入 url 中进行访问，字符串类型，ASCII编码除去 { 和}，最大长度，取决于浏览器</p><p>IE 2KB+35<br>FireFox 64KB<br>Chrome 8KB-10<br>设计的目的是向服务器检索、获取资源信息，参数部分以 ? 开始由 &amp; 分隔键值对，每个 = 左边为键，右边为值</p><p>post 通过提交表单访问<br>可以传入多种数据类型<br>理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。<br>最初的设计也是为了填表，也就是提交、修改、上传信息。</p><h3 id="HTTP和HTTPS的工作方式"><a href="#HTTP和HTTPS的工作方式" class="headerlink" title="HTTP和HTTPS的工作方式"></a>HTTP和HTTPS的工作方式</h3><p>HTTP</p><p>HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p><p>HTTPS</p><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p><p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p><p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p><p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p><p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p><p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secret，并且该报文是经过证书中的公钥加密过的。</p><p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secret 加密的。</p><p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p><p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p><p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p><h3 id="HTTPS-和-HTTP-的区别"><a href="#HTTPS-和-HTTP-的区别" class="headerlink" title="HTTPS 和 HTTP 的区别"></a>HTTPS 和 HTTP 的区别</h3><ul><li><p>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</p></li><li><p>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</p></li><li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li><li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL </li></ul><h3 id="HTTPS-的加密方式"><a href="#HTTPS-的加密方式" class="headerlink" title="HTTPS 的加密方式"></a>HTTPS 的加密方式</h3><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h3 id="客户端为什么会信任第三方证书"><a href="#客户端为什么会信任第三方证书" class="headerlink" title="客户端为什么会信任第三方证书"></a>客户端为什么会信任第三方证书</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口详解与前后端交互实践练习</title>
      <link href="//c9f852c4.html"/>
      <url>//c9f852c4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="接口详解与练习实践"><a href="#接口详解与练习实践" class="headerlink" title="接口详解与练习实践"></a>接口详解与练习实践</h1><p>Spring Boot 框架中的 web 开发模块就是使用了 Spring MVC 框架。不过与普通的 web 项目开发相比，在 Spring Boot 项目中我们并不需要对 Spring MVC 框架进行配置即可使用该框架的相关功能，这是因为 Spring Boot 自动配置机制，Spring MVC 所需的相关类在项目启动过程汇总已经自动配置生效了，下图就是 Spring Boot 官方文档中关于 Spring MVC 自动配置的简介：</p><ul><li>自动配置了 ViewResolver 视图解析器</li><li>静态资源文件夹处理</li><li>自动注册了大量的转换器和格式化器</li><li>提供了 HttpMessageConverter 对请求参数和返回结果进行处理</li><li>自动注册了 MessageCodesResolver</li><li>默认欢迎页配置</li><li>favicon 自动配置</li></ul><h2 id="自动注册-Converter-、Formatter"><a href="#自动注册-Converter-、Formatter" class="headerlink" title="自动注册 Converter 、Formatter"></a>自动注册 Converter 、Formatter</h2><p>在 WebMvcAutoConfigurationAdapter 内部类中，含有 addFormatters() 方法，该方法会向 FormatterRegistry 添加 IOC 容器中所有的 Converter、GenericConverter、Formatter 类型的 bean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">    for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;</span><br><span class="line">        registry.addConverter(converter);</span><br><span class="line">    &#125;</span><br><span class="line">    for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;</span><br><span class="line">        registry.addConverter(converter);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;</span><br><span class="line">        registry.addFormatter(formatter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便大家理解，我们简单的举一个小例子，新建 <code>TestController</code> 类并新增 <code>typeConversionTest()</code> 方法，参数分别为 goodsName(String 类型)、weight(float 类型)、type(int 类型)、onSale(Boolean 类型)，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test/type/conversion&quot;)</span><br><span class="line">    public void typeConversionTest(String goodsName, float weight, int type, Boolean onSale) &#123;</span><br><span class="line">        System.out.println(&quot;goodsName:&quot; + goodsName);</span><br><span class="line">        System.out.println(&quot;weight:&quot; + weight);</span><br><span class="line">        System.out.println(&quot;type:&quot; + type);</span><br><span class="line">        System.out.println(&quot;onSale:&quot; + onSale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们重启项目并在浏览器中输入地址进行请求，看一下打印结果是怎么样的。</p><p>第一次请求：<code>/test/type/conversion?goodsName=iPhoneX&amp;weight=174.5&amp;type=1&amp;onSale=true</code> 打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goodsName:iPhoneX</span><br><span class="line">weight:174.5</span><br><span class="line">type:1</span><br><span class="line">onSale:true</span><br></pre></td></tr></table></figure><p>第二次请求：<code>/test/type/conversion?goodsName=iPhone8&amp;weight=174.5&amp;type=2&amp;onSale=0</code> 打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goodsName:iPhone8</span><br><span class="line">weight:174.5</span><br><span class="line">type:2</span><br><span class="line">onSale:false</span><br></pre></td></tr></table></figure><p>其实这就是 SpringMVC 中的类型转换，Http 请求传递的数据都是字符串 String 类型的，上面这个方法在 Controller 中定义，如果该方法对应的地址接收到到浏览器的请求的话，并且请求中含有 goodsName(String 类型)、weight(float 类型)、type(int 类型)、onSale(Boolean 类型) 参数且都已经被进行正确的类型转换了，如果参数无法通过 String 强转的话也会报错，这就是文章中提到的 MessageCodesResolver 了，朋友们可以自行多测试几次。</p><p>以上是简单的类型转换，如果业务需要的话也可以进行自定义类型转换器添加到项目中。</p><h2 id="消息转换器-HttpMessageConverter"><a href="#消息转换器-HttpMessageConverter" class="headerlink" title="消息转换器 HttpMessageConverter"></a>消息转换器 HttpMessageConverter</h2><p>HttpMessageConverter 的设置也是通过 WebMvcAutoConfigurationAdapter 完成的，源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">        this.messageConvertersProvider.ifAvailable((customConverters) -&gt; converters</span><br><span class="line">                .addAll(customConverters.getConverters()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以往在使用 SpringMVC 框架开发项目时，大家应该都使用过 <code>@RequestBody</code>、<code>@ResponseBody</code> 注解进行请求实体的转换和响应结果的格式化输出，以普遍使用的 json 数据为例，这两个注解的作用分别可以将请求中的数据解析成 json 并绑定为实体对象以及将响应结果以 json 格式返回给请求发起者，但 Http 请求和响应是基于文本的，也就是说在 SpringMVC 内部维护了一套转换机制，也就是我们通常所说的“将 json 格式的请求信息转换为一个对象，将对象转换为 json 格式并输出为响应信息 ”，这些就是 HttpMessageConverter 的作用。</p><p>举一个简单的例子，我们定义一个实体类，并通过 <code>@RequestBody</code>、<code>@ResponseBody</code> 注解进行参数的读取和响应，代码如下：</p><p>在 <code>com.lou.springboot</code> 下创建如下目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.lou.springboot</span><br><span class="line">     ├── Application.java</span><br><span class="line">     ├── controller</span><br><span class="line">     │   ├── HelloController.java</span><br><span class="line">     │   └── TestController.java</span><br><span class="line">     ├── entity</span><br><span class="line">     │   └── SaleGoods.java</span><br><span class="line">     └── service</span><br><span class="line">         └── HelloService.java</span><br></pre></td></tr></table></figure><p><code>SaleGoods.java</code> 的代码内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ackage com.lou.springboot.entity;</span><br><span class="line"></span><br><span class="line">public class SaleGoods &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String goodsName;</span><br><span class="line">    private float weight;</span><br><span class="line">    private int type;</span><br><span class="line">    private Boolean onSale;</span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getGoodsName() &#123;</span><br><span class="line">        return goodsName;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setGoodsName(String goodsName) &#123;</span><br><span class="line">        this.goodsName = goodsName;</span><br><span class="line">    &#125;</span><br><span class="line">    public float getWeight() &#123;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setWeight(float weight) &#123;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    public Boolean getOnSale() &#123;</span><br><span class="line">        return onSale;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setOnSale(Boolean onSale) &#123;</span><br><span class="line">        this.onSale = onSale;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setType(int type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;SaleGoods&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, goodsName=&#x27;&quot; + goodsName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, weight=&quot; + weight +</span><br><span class="line">                &quot;, type=&quot; + type +</span><br><span class="line">                &quot;, onSale=&quot; + onSale +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestController.java</code> 控制器方法如下，拿到参数数值后进行简单的修改并将对象数据返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.lou.springboot.controller;</span><br><span class="line">import com.lou.springboot.entity.SaleGoods;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/get/httpmessageconverter&quot;, method = RequestMethod.GET)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public SaleGoods httpMessageConverterTest() &#123;</span><br><span class="line">        SaleGoods saleGoods = new SaleGoods();</span><br><span class="line">        saleGoods.setGoodsName(&quot;华为手机&quot;);</span><br><span class="line">        saleGoods.setId(1);</span><br><span class="line">        saleGoods.setOnSale(true);</span><br><span class="line">        saleGoods.setType(1);</span><br><span class="line">        saleGoods.setWeight(300);</span><br><span class="line">        return saleGoods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码完成后重启项目，并在地址栏输入 /get/httpmessageconverter 进行测试，结果如下：</p><p><img src="https://doc.shiyanlou.com/courses/2573/358858/41cf7100cbf801f33560755d5ca23b09-0" alt="img"></p><p>返回数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;goodsName&quot;: &quot;华为手机&quot;,</span><br><span class="line">  &quot;weight&quot;: 300.0,</span><br><span class="line">  &quot;type&quot;: 1,</span><br><span class="line">  &quot;onSale&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 <code>@ResponseBody</code> 注解后，Spring Boot 会直接将对象转换为 json 格式并输出为响应信息，这是将对象作为相应数据的例子，接下来我们再写一个案例，使用 <code>@RequestBody</code> 接收前端请求并将参数转换为后端定义的对象，在 <code>TestController</code> 类中添加的方法如下，请求方法为 POST，并使用 <code>@RequestBody</code> 注解将前端传输的参数直接转换为 <code>SaleGoods</code> 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/test/httpmessageconverter&quot;, method = RequestMethod.POST)</span><br><span class="line">  @ResponseBody</span><br><span class="line">  public SaleGoods httpMessageConverterTest2(@RequestBody SaleGoods saleGoods) &#123;</span><br><span class="line">      System.out.println(saleGoods.toString());</span><br><span class="line">      saleGoods.setType(saleGoods.getType() + 1);</span><br><span class="line">      saleGoods.setGoodsName(&quot;商品名：&quot; + saleGoods.getGoodsName());</span><br><span class="line">      return saleGoods;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之后重启项目并进行测试，由于是 POST 请求，因此没有直接使用浏览器访问，而是在 <code>static</code> 中新增了 <code>api-test.html</code> 页面进行模拟请求,页面当中使用的是 applicaiton/json 格式进行 ajax 请求,<code>resources/static/api-test.html</code> 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;lou.SpringBoot | 请求测试&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body class=&quot;hold-transition login-page&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width:720px;margin:7% auto&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">          &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-6&quot;&gt;</span><br><span class="line">              &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;card-header&quot;&gt;</span><br><span class="line">                  &lt;h5 class=&quot;m-0&quot;&gt;接口测试&lt;/h5&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;card-body&quot;&gt;</span><br><span class="line">                  &lt;input id=&quot;id&quot; type=&quot;text&quot; placeholder=&quot;请输入id字段&quot; /&gt;</span><br><span class="line">                  &lt;input</span><br><span class="line">                    id=&quot;goodsName&quot;</span><br><span class="line">                    type=&quot;text&quot;</span><br><span class="line">                    placeholder=&quot;请输入goodsName字段&quot;</span><br><span class="line">                  /&gt;</span><br><span class="line">                  &lt;input</span><br><span class="line">                    id=&quot;weight&quot;</span><br><span class="line">                    type=&quot;number&quot;</span><br><span class="line">                    placeholder=&quot;请输入weight字段&quot;</span><br><span class="line">                  /&gt;</span><br><span class="line">                  &lt;input id=&quot;type&quot; type=&quot;number&quot; placeholder=&quot;请输入type字段&quot; /&gt;</span><br><span class="line">                  &lt;input</span><br><span class="line">                    id=&quot;onSale&quot;</span><br><span class="line">                    type=&quot;number&quot;</span><br><span class="line">                    placeholder=&quot;请输入onSale字段(0或1)&quot;</span><br><span class="line">                  /&gt;</span><br><span class="line">                  &lt;h6 class=&quot;card-title&quot;&gt;接口返回数据如下：&lt;/h6&gt;</span><br><span class="line">                  &lt;p class=&quot;card-text&quot; id=&quot;result2&quot;&gt;&lt;/p&gt;</span><br><span class="line">                  &lt;a</span><br><span class="line">                    href=&quot;#&quot;</span><br><span class="line">                    class=&quot;btn btn-primary&quot;</span><br><span class="line">                    onclick=&quot;requestPostTest()&quot;</span><br><span class="line">                    &gt;发送Post请求&lt;/a</span><br><span class="line">                  &gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;br /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- jQuery --&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.12.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      function requestPostTest() &#123;</span><br><span class="line">        var onSale = true;</span><br><span class="line">        var id = $(&#x27;#id&#x27;).val();</span><br><span class="line">        var goodsName = $(&#x27;#goodsName&#x27;).val();</span><br><span class="line">        var weight = $(&#x27;#weight&#x27;).val();</span><br><span class="line">        var type = $(&#x27;#type&#x27;).val();</span><br><span class="line">        var goodsName = $(&#x27;#goodsName&#x27;).val();</span><br><span class="line">        var onSaleValue = $(&#x27;#onSale&#x27;).val();</span><br><span class="line">        if (onSaleValue != 1) &#123;</span><br><span class="line">          onSale = false;</span><br><span class="line">        &#125;</span><br><span class="line">        var data = &#123;</span><br><span class="line">          id: id,</span><br><span class="line">          goodsName: goodsName,</span><br><span class="line">          weight: weight,</span><br><span class="line">          type: type,</span><br><span class="line">          onSale: onSale,</span><br><span class="line">        &#125;;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          type: &#x27;POST&#x27;, //方法类型</span><br><span class="line">          dataType: &#x27;json&#x27;, //预期服务器返回的数据类型</span><br><span class="line">          url: &#x27;/test/httpmessageconverter&#x27;,</span><br><span class="line">          contentType: &#x27;application/json; charset=utf-8&#x27;,</span><br><span class="line">          data: JSON.stringify(data),</span><br><span class="line">          success: function (result) &#123;</span><br><span class="line">            $(&#x27;#result2&#x27;).html(JSON.stringify(result));</span><br><span class="line">          &#125;,</span><br><span class="line">          error: function () &#123;</span><br><span class="line">            $(&#x27;#result2&#x27;).html(&#x27;接口异常，请联系管理员！&#x27;);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>启动项目后在地址栏访问 <code>api-test.html</code> 页面并在页面输入框中输入对应的数据点击请求按钮，最终获得结果如下：</p><p><img src="https://doc.shiyanlou.com/courses/2573/358858/b2487cb7dfaaced16449266d50de5f02-0" alt="img"></p><p>前端 ajax 传输的数据是 5 个字段，到达后端后直接转换为 SaleGoods 对象。由于消息转换器的存在，对象数据的读取不仅简单而且完全正确，响应时也不用自行封装工具类，使得开发过程变得更加灵活和高效。</p><h1 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h1><p>在实际的前后端分离模式的项目开发中，进行至接口设计阶段时，后端开发人员和前端开发人员都会参与其中，根据已制定的规范对接口进行设计和返回数据格式的约定（不同项目组规范可能不同）。REST 指的是一组架构约束条件和原则。</p><h4 id="基本原则一：URI"><a href="#基本原则一：URI" class="headerlink" title="基本原则一：URI"></a>基本原则一：URI</h4><ul><li>应该将 api 部署在专用域名之下。</li><li>URL 中尽量不用大写。</li><li>URI 中不应该出现动词，动词应该使用 HTTP 方法表示但是如果无法表示，也可使用动词，例如：search 没有对应的 HTTP 方法，可以在路径中使用 search，更加直观。</li><li>URI 中的名词表示资源集合，使用复数形式。</li><li>URI 可以包含 queryString，避免层级过深。</li></ul><h4 id="基本原则二：HTTP-动词"><a href="#基本原则二：HTTP-动词" class="headerlink" title="基本原则二：HTTP 动词"></a>基本原则二：HTTP 动词</h4><p>对于资源的具体操作类型，由 HTTP 动词表示，常用的 HTTP 动词有下面五个：</p><ul><li><strong>GET：从服务器取出资源（一项或多项）。</strong></li><li><strong>POST：在服务器新建一个资源。</strong></li><li><strong>PUT：在服务器更新资源（客户端提供改变后的完整资源）。</strong></li><li><strong>PATCH：在服务器更新资源（客户端提供改变的属性）。</strong></li><li><strong>DELETE：从服务器删除资源。</strong></li></ul><p>还有两个不常用的 HTTP 动词：</p><ul><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><p>例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户管理模块：</span><br><span class="line"></span><br><span class="line">1. [POST]   http：//lou.springboot.tech/users   // 新增</span><br><span class="line">2. [GET]    http：//lou.springboot.tech/users?page=1&amp;rows=10 // 列表查询</span><br><span class="line">3. [PUT]    http：//lou.springboot.tech/users/12 // 修改</span><br><span class="line">4. [DELETE] http：//lou.springboot.tech/users/12 // 删除</span><br></pre></td></tr></table></figure></p><h4 id="基本原则三：状态码（Status-Codes）"><a href="#基本原则三：状态码（Status-Codes）" class="headerlink" title="基本原则三：状态码（Status Codes）"></a>基本原则三：状态码（Status Codes）</h4><p>处理请求后，服务端需向客户端返回的状态码和提示信息。</p><p>常见状态码（状态码可自行设计，只需开发者约定好规范即可）：</p><ul><li>200：SUCCESS 请求成功。</li><li>401：Unauthorized 无权限。</li><li>403：Forbidden 禁止访问。</li><li>410：Gone 无此资源。</li><li>500：INTERNAL SERVER ERROR 服务器发生错误。 …</li></ul><h4 id="基本原则四：错误处理"><a href="#基本原则四：错误处理" class="headerlink" title="基本原则四：错误处理"></a>基本原则四：错误处理</h4><p>如果服务器发生错误或者资源不可达，应该向用户返回出错信息。</p><h4 id="基本原则五：服务端数据返回"><a href="#基本原则五：服务端数据返回" class="headerlink" title="基本原则五：服务端数据返回"></a>基本原则五：服务端数据返回</h4><p>后端的返回结果最好使用 JSON 格式，且格式统一。</p><h4 id="基本原则六：版本控制"><a href="#基本原则六：版本控制" class="headerlink" title="基本原则六：版本控制"></a>基本原则六：版本控制</h4><ul><li>规范的 api 应该包含版本信息，在 RESTful api 中，最简单的包含版本的方法是将版本信息放到 url 中，如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GET]    http：//lou.springboot.tech/v1/users?page=1&amp;rows=10</span><br><span class="line">[PUT]    http：//lou.springboot.tech/v1/users/12</span><br></pre></td></tr></table></figure><ul><li>另一种做法是，使用 HTTP header 中的 accept 来传递版本信息。</li></ul><p>以下为接口安全原则的注意事项：</p><h4 id="安全原则一：Authentication-和-Permission"><a href="#安全原则一：Authentication-和-Permission" class="headerlink" title="安全原则一：Authentication 和 Permission"></a>安全原则一：Authentication 和 Permission</h4><p>Authentication 指用户认证，Permission 指权限机制，这两点是使 RESTful api 强大、灵活和安全的基本保障。</p><p>常用的认证机制是 Basic Auth 和 OAuth，RESTful api 开发中，除非 api 非常简单，且没有潜在的安全性问题，否则，<strong>认证机制是必须实现的</strong>，并应用到 api 中去。Basic Auth 非常简单，很多框架都集成了 Basic Auth 的实现，自己写一个也能很快搞定，OAuth 目前已经成为企业级服务的标配，其相关的开源实现方案非常丰富。</p><h4 id="安全原则二：CORS"><a href="#安全原则二：CORS" class="headerlink" title="安全原则二：CORS"></a>安全原则二：CORS</h4><p>CORS 即 Cross-origin resource sharing，在 RESTful api 开发中，主要是为 js 服务的，解决调用 RESTful api 时的跨域问题。</p><p>由于固有的安全机制，js 的跨域请求时是无法被服务器成功响应的。现在前后端分离日益成为 web 开发主流方式的大趋势下，后台逐渐趋向指提供 api 服务，为各客户端提供数据及相关操作，而网站的开发全部交给前端搞定，网站和 api 服务很少部署在同一台服务器上并使用相同的端口，js 的跨域请求时普遍存在的，开发 RESTful api 时，通常都要考虑到 CORS 功能的实现，以便 js 能正常使用 api。</p><p>目前各主流 web 开发语言都有很多优秀的实现 CORS 的开源库，我们在开发 RESTful api 时，要注意 CORS 功能的实现，直接拿现有的轮子来用即可。</p><h4 id="后端接口实现"><a href="#后端接口实现" class="headerlink" title="后端接口实现"></a>后端接口实现</h4><p>我们会按照 api 规范进行接口设计和接口调用，以对 <code>tb_user</code> 表进行增删改查为例进行实践，<code>tb_user</code> 表的建表语句在实验 7 中已经给出。</p><p>在<code>com.lou.springboot.controller</code>下新建 <code>ApiController</code> 类，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class Apicontroller&#123;</span><br><span class="line">static Map&lt;Integer,User&gt; usersMap = Collections.synchronizedMap(new HashMap&lt;Integer,User&gt;());</span><br><span class="line">static&#123;</span><br><span class="line">User user = new User();</span><br><span class="line">user.setId(2);</span><br><span class="line">user.setName(&quot;user1&quot;);</span><br><span class="line">        user.setPassword(&quot;123456&quot;);</span><br><span class="line">        User user2 = new User();</span><br><span class="line">        user2.setId(5);</span><br><span class="line">        user2.setName(&quot;13-5&quot;);</span><br><span class="line">        user2.setPassword(&quot;4&quot;);</span><br><span class="line">        User user3 = new User();</span><br><span class="line">        user3.setId(6);</span><br><span class="line">        user3.setName(&quot;12&quot;);</span><br><span class="line">        user3.setPassword(&quot;123&quot;);</span><br><span class="line">        usersMap.put(2, user);</span><br><span class="line">        usersMap.put(5, user2);</span><br><span class="line">        usersMap.put(6, user3);</span><br><span class="line">&#125;</span><br><span class="line">//查询一条记录</span><br><span class="line">@RequestMapping(value=&quot;/users/&#123;id&#125;&quot;,method=&quot;Requestmethod.GET&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Result&lt;User&gt; getOne(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">if(id==null||id&lt;1) return ResultGenerator.genFailResult(&quot;缺少参数&quot;)；</span><br><span class="line">User user = userMap.get(id);</span><br><span class="line">if(user == null) return ResultGenerator.genFailResult(&quot;无此数据&quot;);</span><br><span class="line">return ResultGenerator.genSuccessResult(user);</span><br><span class="line">&#125;</span><br><span class="line">//查询所有记录</span><br><span class="line">@RequestMapping(value=&quot;/users&quot;,method=&quot;RequestMethod.GET&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Result&lt;List&lt;User&gt;&gt; queryAll()&#123;</span><br><span class="line">List&lt;User&gt; users = new ArrayList(User);</span><br><span class="line">return ResultGenerator.genSuccessResult(users);</span><br><span class="line">&#125;</span><br><span class="line">//新增一条记录</span><br><span class="line">@RequestMapping(value=&quot;/users&quot;,method=&quot;RequestMethod.POST&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">    // 修改一条记录</span><br><span class="line">    @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.PUT)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public Result&lt;Boolean&gt; update(@RequestBody User tempUser) &#123;</span><br><span class="line">        //参数验证</span><br><span class="line">        if (tempUser.getId() == null || tempUser.getId() &lt; 1 || StringUtils.isEmpty(tempUser.getName()) || StringUtils.isEmpty(tempUser.getPassword())) &#123;</span><br><span class="line">            return ResultGenerator.genFailResult(&quot;缺少参数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //实体验证，不存在则不继续修改操作</span><br><span class="line">        User user = usersMap.get(tempUser.getId());</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            return ResultGenerator.genFailResult(&quot;参数异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        user.setName(tempUser.getName());</span><br><span class="line">        user.setPassword(tempUser.getPassword());</span><br><span class="line">        usersMap.put(tempUser.getId(), tempUser);</span><br><span class="line">        return ResultGenerator.genSuccessResult(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除一条记录</span><br><span class="line">    @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public Result&lt;Boolean&gt; delete(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        if (id == null || id &lt; 1) &#123;</span><br><span class="line">            return ResultGenerator.genFailResult(&quot;缺少参数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        usersMap.remove(id);</span><br><span class="line">        return ResultGenerator.genSuccessResult(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据前端不同的资源请求，我们按照前文中 <code>HTTP</code> 动词的要求对接口的请求类型进行设置，用户数据查询方法使用 <code>GET</code> 请求，用户添加方法使用 <code>POST</code> 请求，对应的修改和删除操作使用 <code>PUT</code> 和 <code>DELETE</code> 请求，同时对于 <code>api</code> 的请求路径也按照设计规范进行设置，分别是 xxx xxx 等，虽然有些映射路径相同，但是会根据请求方法进行区分，比如：同样是 <code>/users</code> 路径，如果请求方法为 <code>POST</code> 则表示添加资源会调用 <code>insert()</code> 方法，而请求方法为 <code>PUT</code> 时则表示修改资源会调用 <code>update()</code> 方法，还有 <code>/users/&#123;id&#125;</code> 路径，会根据 <code>GET</code> 请求方式和 <code>DELETE</code> 请求方式进行区分表示获取单个资源和删除单个资源。同时，每一个返回结果我们都统一使用 <code>Result</code> 类进行包装之后再返回给前端，并使用 <code>@ResponseBody</code> 注解将其转换为 <code>json</code> 格式。</p><h4 id="前端页面和-js-方法实现"><a href="#前端页面和-js-方法实现" class="headerlink" title="前端页面和 js 方法实现"></a>前端页面和 js 方法实现</h4><p>本功能主要包括对于 tb_user 表增删改查功能的调用和结果显示，每个接口测试模块包括信息录入的 input 框和发送请求按钮以及结果显示的 div，点击不同的按钮分别触发不同的 js 方法，我们计划在 js 方法中使用 Ajax 对后端发送不同的请求，实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.12.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  function requestQuery() &#123;</span><br><span class="line">    var id = $(&#x27;#queryId&#x27;).val();</span><br><span class="line">    if (typeof id == &#x27;undefined&#x27; || id == null || id == &#x27;&#x27; || id &lt; 0) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      type: &#x27;GET&#x27;, //方法类型</span><br><span class="line">      dataType: &#x27;json&#x27;, //预期服务器返回的数据类型</span><br><span class="line">      url: &#x27;/api/users/&#x27; + id,</span><br><span class="line">      contentType: &#x27;application/json; charset=utf-8&#x27;,</span><br><span class="line">      success: function (result) &#123;</span><br><span class="line">        $(&#x27;#result0&#x27;).html(JSON.stringify(result));</span><br><span class="line">      &#125;,</span><br><span class="line">      error: function () &#123;</span><br><span class="line">        $(&#x27;#result0&#x27;).html(&#x27;接口异常，请联系管理员！&#x27;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  function requestQueryList() &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      type: &#x27;GET&#x27;, //方法类型</span><br><span class="line">      dataType: &#x27;json&#x27;, //预期服务器返回的数据类型</span><br><span class="line">      url: &#x27;/api/users&#x27;,</span><br><span class="line">      contentType: &#x27;application/json; charset=utf-8&#x27;,</span><br><span class="line">      success: function (result) &#123;</span><br><span class="line">        $(&#x27;#result1&#x27;).html(JSON.stringify(result));</span><br><span class="line">      &#125;,</span><br><span class="line">      error: function () &#123;</span><br><span class="line">        $(&#x27;#result1&#x27;).html(&#x27;接口异常，请联系管理员！&#x27;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  function requestAdd() &#123;</span><br><span class="line">    var id = $(&#x27;#addId&#x27;).val();</span><br><span class="line">    var name = $(&#x27;#addName&#x27;).val();</span><br><span class="line">    var password = $(&#x27;#addPassword&#x27;).val();</span><br><span class="line">    var data = &#123; id: id, name: name, password: password &#125;;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      type: &#x27;POST&#x27;, //方法类型</span><br><span class="line">      dataType: &#x27;json&#x27;, //预期服务器返回的数据类型</span><br><span class="line">      url: &#x27;/api/users&#x27;,</span><br><span class="line">      contentType: &#x27;application/json; charset=utf-8&#x27;,</span><br><span class="line">      data: JSON.stringify(data),</span><br><span class="line">      success: function (result) &#123;</span><br><span class="line">        $(&#x27;#result2&#x27;).html(JSON.stringify(result));</span><br><span class="line">      &#125;,</span><br><span class="line">      error: function () &#123;</span><br><span class="line">        $(&#x27;#result2&#x27;).html(&#x27;接口异常，请联系管理员！&#x27;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  function requestUpdate() &#123;</span><br><span class="line">    var id = $(&#x27;#updateId&#x27;).val();</span><br><span class="line">    var name = $(&#x27;#updateName&#x27;).val();</span><br><span class="line">    var password = $(&#x27;#updatePassword&#x27;).val();</span><br><span class="line">    var data = &#123; id: id, name: name, password: password &#125;;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      type: &#x27;PUT&#x27;, //方法类型</span><br><span class="line">      dataType: &#x27;json&#x27;, //预期服务器返回的数据类型</span><br><span class="line">      url: &#x27;/api/users&#x27;,</span><br><span class="line">      contentType: &#x27;application/json; charset=utf-8&#x27;,</span><br><span class="line">      data: JSON.stringify(data),</span><br><span class="line">      success: function (result) &#123;</span><br><span class="line">        $(&#x27;#result3&#x27;).html(JSON.stringify(result));</span><br><span class="line">      &#125;,</span><br><span class="line">      error: function () &#123;</span><br><span class="line">        $(&#x27;#result3&#x27;).html(&#x27;接口异常，请联系管理员！&#x27;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  function requestDelete() &#123;</span><br><span class="line">    var id = $(&#x27;#deleteId&#x27;).val();</span><br><span class="line">    if (typeof id == &#x27;undefined&#x27; || id == null || id == &#x27;&#x27; || id &lt; 0) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      type: &#x27;DELETE&#x27;, //方法类型</span><br><span class="line">      dataType: &#x27;json&#x27;, //预期服务器返回的数据类型</span><br><span class="line">      url: &#x27;/api/users/&#x27; + id,</span><br><span class="line">      contentType: &#x27;application/json; charset=utf-8&#x27;,</span><br><span class="line">      success: function (result) &#123;</span><br><span class="line">        $(&#x27;#result4&#x27;).html(JSON.stringify(result));</span><br><span class="line">      &#125;,</span><br><span class="line">      error: function () &#123;</span><br><span class="line">        $(&#x27;#result4&#x27;).html(&#x27;接口异常，请联系管理员！&#x27;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>每个请求按钮点击后会触发不同的 <code>js</code> 方法。以修改请求为例，该按钮点击后会触发 <code>requestUpdate()</code> 方法，该方法中首先会获取用户输入的数据，之后将其封装到 <code>data</code> 中，同时设置请求的 url 为 <code>/api/users</code>。由于是修改用户数据，因此将请求方法设置为 <code>PUT</code> 方法，之后向后端发送请求，而后端代码在前文中已经介绍，请求地址为 <code>/api/users</code> 且请求方法为 <code>PUT</code> 时会调用修改方法将用户数据进行修改。删除请求也是如此，首先用户输入一个需要删除的 <code>id</code>，之后根据该 <code>id</code> 将其拼接到 url 中，同时设置请求的 url 为 <code>/api/users/&#123;id&#125;</code>。由于是删除用户数据，因此将请求方法设置为 <code>DELETE</code> 方法，之后向后端发送请求，后端在收到请求后会根据请求方法和请求地址进行映射匹配，可以通过后端代码得知，该请求最终会被控制器中的 <code>delete()</code> 方法处理，其它的调用流程与此类似，可以参考着进行理解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="//9211474f.html"/>
      <url>//9211474f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="常用文件管理命令"><a href="#常用文件管理命令" class="headerlink" title="常用文件管理命令"></a>常用文件管理命令</h2><p>平常常用的命令也就那几个，可以先熟悉这几个，其它的现查现写。</p><p>取消命令，并且换行  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+c</span><br></pre></td></tr></table></figure><p>清空本行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+u</span><br></pre></td></tr></table></figure><p>补全命令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab</span><br></pre></td></tr></table></figure><p>显示当前目录下文件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls  //详细显示文件信息 ls -a </span><br></pre></td></tr></table></figure><p>进入某个目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd </span><br></pre></td></tr></table></figure><p>显示当前路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p>创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir direname</span><br></pre></td></tr></table></figure><p>删除文件和目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm filename or rm -r direname</span><br></pre></td></tr></table></figure><p>复制文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp filenameroute newfilenamerout </span><br></pre></td></tr></table></figure></p><p>移动文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv filenameroute newfilenameroute</span><br></pre></td></tr></table></figure><p>创建一个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch txtname</span><br></pre></td></tr></table></figure><p>查看文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure><p>复制文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+insert</span><br></pre></td></tr></table></figure><p>粘贴文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift+insert</span><br></pre></td></tr></table></figure><h2 id="tmux和vim"><a href="#tmux和vim" class="headerlink" title="tmux和vim"></a>tmux和vim</h2><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p> 一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。<br>    实例：<br>        tmux:<br>            session 0:<br>                window 0:<br>                    pane 0<br>                    pane 1<br>                    pane 2<br>                    …<br>                window 1<br>                window 2<br>                …<br>            session 1<br>            session 2<br>            …</p><p>命令</p><h2 id="shell语法"><a href="#shell语法" class="headerlink" title="shell语法"></a>shell语法</h2><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h2 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h2><h2 id="管道、环境变量和常用命令"><a href="#管道、环境变量和常用命令" class="headerlink" title="管道、环境变量和常用命令"></a>管道、环境变量和常用命令</h2><h2 id="租云服务器及配docker环境"><a href="#租云服务器及配docker环境" class="headerlink" title="租云服务器及配docker环境"></a>租云服务器及配docker环境</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合lombok</title>
      <link href="//9728e675.html"/>
      <url>//9728e675.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Lombok简介"><a href="#Lombok简介" class="headerlink" title="Lombok简介"></a>Lombok简介</h2><blockquote><p>Lombok 项目是一个第三方的 Java 工具库，它会自动插入编辑器和构建工具中，Lombok 提供了一组非常有用的注释，用来消除 Java 类中的大量样板代码，比如 setter getter 方法、构造方法等等， 仅仅在原来的 JavaBean 类上使用 <code>@Data</code> 注解就可以替换数百行代码从而使代码变得更加清爽、简洁且易于维护。</p></blockquote><p>大家可以将它理解为一个工具，仅此而已，千万不要觉得它是一个非用不可的框架。比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Carousel &#123;</span><br><span class="line">       private Integer carouselId;</span><br><span class="line">       private String carouselUrl;</span><br><span class="line">       private String redirectUrl;</span><br><span class="line">       private Integer carouselRank;</span><br><span class="line">       private Byte isDeleted;</span><br><span class="line">       private Date createTime;</span><br><span class="line">       private Integer createUser;</span><br><span class="line">       private Date updateTime;</span><br><span class="line">       private Integer updateUser;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果想要在项目中使用这个对象，我们就必须还要给每一个字段加上 setter 和 getter 方法，有可能还要写构造方法、equals() 方法、toString() 方法等等，这些方法量多而且没有技术含量，但是我们又不得不去写它们。</p><p>此时，Lombok 出现了，这个工具的主要作用是通过一些注解，消除刚刚提到的这种看似无用但是又不得不写的代码，Lombok 的解决方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">   public class Carousel &#123;</span><br><span class="line">       private Integer carouselId;</span><br><span class="line">       private String carouselUrl;</span><br><span class="line">       private String redirectUrl;</span><br><span class="line">       private Integer carouselRank;</span><br><span class="line">       private Byte isDeleted;</span><br><span class="line">       private Date createTime;</span><br><span class="line">       private Integer createUser;</span><br><span class="line">       private Date updateTime;</span><br><span class="line">       private Integer updateUser;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>仅仅加一个 <code>@Data</code> 注解即可，接下来我们再来看一下 Carousel 这个 POJO 类的结构：</p><div align='center'>  <img src='../images/0001.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><p>我们仅仅在类上添加了一个注解，并没有添加 setter/getter 等方法，但是这些方法已经自动生成了，这就是 Lombok 的作用。</p><p>Lombok 想要解决的是在我们 POJO 类中大量的 getter/setter、equals()、toString() 等等可能不会用到但是仍然需要在类中定义的方法，在使用 Lombok 之后，将由其它来自动帮你实现代码生成，将极大减少你的代码量、精简和优化这些 POJO 类。</p><h2 id="Spring-Boot-整合-Lombok"><a href="#Spring-Boot-整合-Lombok" class="headerlink" title="Spring Boot 整合 Lombok"></a>Spring Boot 整合 Lombok</h2><p>整合 Lombok 还是比较简单的，只需要在 Spring Boot 项目的 pom.xml 依赖文件中添加 Lombok 的依赖即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.18.8&lt;/version&gt;</span><br><span class="line">          &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>定义一个 POJO 并添加 <code>@Data</code> 注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class MallPOJO &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    private int number;</span><br><span class="line">    private Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后你就可以在其它类中构造 MallPOJO 类以及调用其中的 getter/setter toString() 等方法了。</p><h2 id="Lombok-插件安装"><a href="#Lombok-插件安装" class="headerlink" title="Lombok 插件安装"></a>Lombok 插件安装</h2><div align='center'>  <img src='../images/0002.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SPring与Mybatis整合实现对数据库的操作</title>
      <link href="//8f44674f.html"/>
      <url>//8f44674f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h2><p>MyBatis 的前身是 Apache 社区的一个开源项目 iBatis，于 2010 年更名为 MyBatis。MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集，使得开发人员更加关注 SQL 本身和业务逻辑，不用再去花费时间关注整个复杂的 JDBC 操作过程。</p><p>MyBatis 的优点如下：</p><ul><li>封装了 JDBC 大部分操作，减少开发人员工作量；</li><li>相比一些自动化的 ORM 框架，“半自动化”使得开发人员可以自由的编写 SQL 语句，灵活度更高；</li><li>Java 代码与 SQL 语句分离，降低维护难度；</li><li>自动映射结果集，减少重复的编码工作；</li><li>开源社区十分活跃，文档齐全，学习成本不高。</li></ul><p>虽然前文中已经介绍了 JdbcTemplate 的自动配置及使用，鉴于 MyBatis 框架受众更广且后续实践课程的技术选型包含 MyBatis，因此会在本章节内容中对它做一个详细的介绍，以及如何使用 Spring Boot 整合 MyBatis 框架对数据层进行功能开发。</p><h2 id="mybatis-springboot-starter-介绍"><a href="#mybatis-springboot-starter-介绍" class="headerlink" title="mybatis-springboot-starter 介绍"></a>mybatis-springboot-starter 介绍</h2><p>Spring Boot 的核心特性包括简化配置并快速开发，当我们需要整合某一个功能时，只需要引入其特定的场景启动器 ( starter ) 即可，比如 web 模块整合、jdbc 模块整合，我们在开发时只需要在 pom.xml 文件中引入对应的场景依赖即可。Spring 官方并没有提供 MyBatis 的场景启动器，但是 MyBatis 官方却紧紧的抱住了 Spring 的大腿，他们提供了 MyBatis 整合 Spring Boot 项目时的场景启动器，也就是 <strong>mybatis-springboot-starter</strong>，大家通过命名方式也能够发现其中的区别，Spring 官方提供的启动器的命名方式为 <strong>spring-boot-starter-*</strong>，与它还是有一些差别的，接下来我们来介绍一下 <strong>mybatis-springboot-starter</strong> 场景启动器。</p><p>其官网地址为 <a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/index.html">mybatis-spring-boot</a>，感兴趣的朋友可以去查看更多内容，官网对 <strong>mybatis-springboot-starter</strong> 的介绍如下所示：</p><p>MyBatis-Spring-Boot-Starter 可以帮助开发者快速创建基于 Spring Boot 的 MyBatis 应用程序，那么使用 <strong>MyBatis-Spring-Boot-Starter</strong> 可以做什么呢？</p><ul><li>构建独立的 MyBatis 应用程序</li><li>零模板</li><li>更少的 XML 配置代码甚至无 XML 配置</li></ul><h2 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h2><h3 id="添加项目依赖"><a href="#添加项目依赖" class="headerlink" title="添加项目依赖"></a>添加项目依赖</h3><p>如果要将mybatis整合到springboot项目中，首先要添加项目依赖，在pom.xml中添加。mybatis-springboot-starter 的最新稳定版本版本为 2.1.1，可以在它的开源仓库中看到：</p><p><img src="https://doc.shiyanlou.com/courses/2573/358858/58a300fab5f99cf5668f2a714edc775b-0" alt="img"></p><p>之后我们需要将数据源依赖和 jdbc 依赖也添加到配置文件中（如果不添加的话，将会使用默认数据源和 jdbc 配置），在pom.xml中添加一下代码即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这样，MyBatis 的场景启动器也整合进来项目中了。</p><h3 id="application-properties-配置"><a href="#application-properties-配置" class="headerlink" title="application.properties 配置"></a>application.properties 配置</h3><p>然后去配置application.properties，Spring Boot 整合 MyBatis 时几个比较需要注意的配置参数：</p><ul><li><p><strong>mybatis.config-location</strong></p><p>配置 <code>mybatis-config.xml</code> 路径，<code>mybatis-config.xml</code> 中配置 MyBatis 基础属性，如果项目中配置了 <code>mybatis-config.xml</code> 文件需要设置该参数。</p></li><li><p><strong>mybatis.mapper-locations</strong></p><p>配置 Mapper 文件对应的 XML 文件路径。</p></li><li><p><strong>mybatis.type-aliases-package</strong></p></li></ul><p>配置项目中实体类包路径</p><p>在application.properties中添加这个即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location=classpath:mybatis-config.xml</span><br><span class="line">mybatis.mapper-locations=classpath:mapper/*Dao.xml</span><br><span class="line">mybatis.type-aliases-package=com.lou.springboot.entity</span><br></pre></td></tr></table></figure><h3 id="启动类增加-Mapper-扫描"><a href="#启动类增加-Mapper-扫描" class="headerlink" title="启动类增加 Mapper 扫描"></a>启动类增加 Mapper 扫描</h3><p>在启动类中添加对 Mapper 包扫描 @MapperScan，Spring Boot 启动的时候会自动加载包路径下的 Mapper 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Spring BootApplication</span><br><span class="line">@MapperScan(&quot;com.lou.springboot.dao&quot;) //添加 @Mapper 注解</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;启动 Spring Boot...&quot;);</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mysql准备"><a href="#mysql准备" class="headerlink" title="mysql准备"></a>mysql准备</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create database lou_springboot;</span><br><span class="line"></span><br><span class="line">USE lou_springboot;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tb_user` (</span><br><span class="line">  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `name` VARCHAR(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;登录名&#x27;,</span><br><span class="line">  `password` VARCHAR(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>本次实验我们会使用 MyBatis 知识对该表进行增删改查操作，接下来是功能实现步骤。</p><h3 id="新建实体类和-Mapper-接口"><a href="#新建实体类和-Mapper-接口" class="headerlink" title="新建实体类和 Mapper 接口"></a>新建实体类和 Mapper 接口</h3><p>在 <code>entity</code> 包下新建 <code>User</code> 类，将 <code>tb_user</code> 中的字段映射到该实体类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.lou.springboot.entity;</span><br><span class="line">public class User&#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">private String password;</span><br><span class="line">public void setId(Integer id)&#123;</span><br><span class="line">this.id=id;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getId()&#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public String getName()&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public String getPassword()&#123;</span><br><span class="line">return password;</span><br><span class="line">&#125;</span><br><span class="line">public String  setName(String name)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">public String setPassword(String password)&#123;</span><br><span class="line">this.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>dao</code> 包中新建 <code>UserDao</code> 接口，并定义增删改查四个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.lou.springboot.dao;</span><br><span class="line">import com.lou.springboot.entity.User;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public interface UserDao&#123;</span><br><span class="line">List&lt;User&gt; findallusers();</span><br><span class="line">int insertUser(User user);</span><br><span class="line">int delUser(User user);</span><br><span class="line">int updateUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-Mapper-接口的映射文件"><a href="#创建-Mapper-接口的映射文件" class="headerlink" title="创建 Mapper 接口的映射文件"></a>创建 Mapper 接口的映射文件</h3><p>在 <code>resources/mapper</code> 目录下新建 Mapper 接口的映射文件 <code>UserDao.xml</code>，之后进行映射文件的编写。</p><p>首先，定义映射文件与 Mapper 接口的对应关系，比如该示例中，需要将 <code>UserDao.xml</code> 的与对应的 <code>UserDao</code> 接口类之间的关系定义出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.lou.springboot.dao.UserDao&quot;&gt;</span><br></pre></td></tr></table></figure><p>之后，配置表结构和实体类的对应关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;com.lou.springboot.entity.User&quot; id=&quot;UserResult&quot;&gt;</span><br><span class="line">&lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;password&quot; column =&quot;password&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>最后，针对对应的接口方法，编写具体的 SQL 语句，最终的 <code>UserDao.xml</code> 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;map namespace=&quot;com.lou.springboot.dao.UserDao&quot;&gt;</span><br><span class="line">&lt;resultMap type=&quot;com.lou.springboot.entite.User&quot; id=&quot;UserResult&quot;&gt;</span><br><span class="line">&lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;findallusers&quot; resultMap=&quot;UserResult&quot;&gt;</span><br><span class="line">select id,name,password from tb_user oder by id esc</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;insert id=&quot;insertUser&quot; resultMap=&quot;UserResult&quot;&gt;</span><br><span class="line">insert into tb_user(id,name,password) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;update id=&quot;updateUser&quot; resultMap=&quot;UserResult&quot;&gt;</span><br><span class="line">update tb_user set name=#&#123;name&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br><span class="line">&lt;delete id=&quot;delUser&quot; resultMap=&quot;UserResult&quot;&gt;</span><br><span class="line">delete from tb_user where id=#&#123;id&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><h3 id="新建-MyBatisController"><a href="#新建-MyBatisController" class="headerlink" title="新建 MyBatisController"></a>新建 MyBatisController</h3><p>为了对 MyBatis 进行功能测试，在 <code>controller</code> 包下新建 <code>MyBatisController</code> 类，并新增 4 个方法分别接收对于 <code>tb_user</code> 表的增删改查请求，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.lou.springboot.controller;</span><br><span class="line"></span><br><span class="line">public class MybatisController&#123;</span><br><span class="line"> UserDao userDao;</span><br><span class="line"> public List&lt;User&gt; findallusers()&#123;</span><br><span class="line"> return userDao.findallusers();</span><br><span class="line"> &#125;</span><br><span class="line"> public Boolean insert(int id,String name,String password)&#123;</span><br><span class="line"> if(Integerutils.isEmpty(id)||StringUtils.isEmpty(name)||StringUtils.isEmpty(password)) return false;</span><br><span class="line"> User user = new User();</span><br><span class="line"> user.setName(name);</span><br><span class="line"> user.setPassword(password);</span><br><span class="line"> return userDao.insertUser(user)&gt;0;</span><br><span class="line"> &#125;</span><br><span class="line"> public Boolean update(String name,String password)&#123;</span><br><span class="line">if(Stringutils.isEmpty(name)||StringUtils.isEmpty(password)) return fasle;</span><br><span class="line">User user = new User();</span><br><span class="line">user.setName(name);</span><br><span class="line">user.setPassword(password);</span><br><span class="line">return userDao.updateUser(user)&gt;0;</span><br><span class="line">&#125;</span><br><span class="line">public Boolean delete(int id)&#123;</span><br><span class="line">if(id==null||id&lt;1) return false;</span><br><span class="line">User user = new User();</span><br><span class="line">user.setId(id);</span><br><span class="line">return delUser(user)&gt;0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="//78cea6d8.html"/>
      <url>//78cea6d8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Less-是什么"><a href="#Less-是什么" class="headerlink" title="Less 是什么"></a>Less 是什么</h2><p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。 Less 可以运行在 Node 或浏览器端。最基础的例子如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@base:#fff   //定义颜色变量</span><br><span class="line">.wh(@height,@weight)&#123;</span><br><span class="line">width:@width;</span><br><span class="line">height:@height;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">color:@base;</span><br><span class="line">.wh(&#x27;30px&#x27;,&#x27;30px&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译输出后的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">  width: &#x27;30px&#x27;;</span><br><span class="line">  height: &#x27;30px&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Less中的注释"><a href="#Less中的注释" class="headerlink" title="Less中的注释"></a>Less中的注释</h2><p>我们在写代码的时候，会记录一下这段代码的功能或者使用注意事项等，Less 也不例外，两种注释形式：</p><ul><li>以 <code>//</code> 开头的注释，注释单行，且不会被编译到 CSS 文件中。</li><li>以 <code>/**/</code> 包裹的注释，注释多行，同样也不会被编译到 CSS 文件中。</li></ul><h2 id="Less中的变量"><a href="#Less中的变量" class="headerlink" title="Less中的变量"></a>Less中的变量</h2><p>Less 中使用 <code>@</code> 符号申明变量，比如 <code>@color: red</code>。比方说我现在写一个电商项目，我需要设置项目中主色、辅助色等，代码如下所示： App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;p class=&quot;one&quot;&gt;我是less&lt;/p&gt;</span><br><span class="line">      &lt;p class=&quot;two&quot;&gt;我是less&lt;/p&gt;</span><br><span class="line">      &lt;p class=&quot;three&quot;&gt;我是less&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">@primary: red;</span><br><span class="line">@deepColor: green;</span><br><span class="line">@lightColor: blue;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  .one &#123;</span><br><span class="line">    color: @primary;</span><br><span class="line">  &#125;</span><br><span class="line">  .two &#123;</span><br><span class="line">    color: @deepColor;</span><br><span class="line">  &#125;</span><br><span class="line">  .three &#123;</span><br><span class="line">    color: @lightColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>浏览器展示如下所示：</p><div align='center'>  <img src='../images/111.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><p>有一点要注意的是，如果在后面声明了同名变量，变量值会被后面的覆盖，比如上述代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@primary: red;</span><br><span class="line">@deepColor: green;</span><br><span class="line">@lightColor: blue;</span><br><span class="line">@primary: pink .box&#123;</span><br><span class="line">  .one &#123;</span><br><span class="line">    color: @primary;</span><br><span class="line">  &#125;</span><br><span class="line">  .two &#123;</span><br><span class="line">    color: @deepColor;</span><br><span class="line">  &#125;</span><br><span class="line">  .three &#123;</span><br><span class="line">    color: @lightColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么最后第一个 p 标签的文字就会变成粉红色。颜色可以写成变量，文字的大小同样也可以，并且 less 文件能通过 <code>@import</code> 关键词引入其他的 less 文件。</p><h2 id="Less-中的嵌套"><a href="#Less-中的嵌套" class="headerlink" title="Less 中的嵌套"></a>Less 中的嵌套</h2><p>市面上所有 CSS 的预编译器的嵌套规则大同小异，基本嵌套如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">  .b &#123;</span><br><span class="line">    width: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">&#125;</span><br><span class="line">.a .b &#123;</span><br><span class="line">  width: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同级场景 <code>&amp;</code> 的使用如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码 <code>&amp;</code> 表示当前节点的 CSS 样式，一般用于处理 CSS 样式的状态 hover、focus、active、link、visited 等。</p><h2 id="Less-中的混合（Mixin）"><a href="#Less-中的混合（Mixin）" class="headerlink" title="Less 中的混合（Mixin）"></a>Less 中的混合（Mixin）</h2><p>Less 的混合有三种情况：</p><ul><li>不带参数；</li><li>带参数，没有默认值；</li><li>带参数，且有设置默认值；</li></ul><p>调用的时候也存在区别：</p><ul><li>不带参数：调用时可以不加括号，直接使用；</li><li>带参数：调用时要加括号，括号里必须要传值，不然编译会报错；</li><li>带参数且有默认值：调用时要加括号，参数可传可不穿；</li></ul><p>下面就用上面的项目页面进行实验，首先是第一种情况，不带参数，用 <code>.center</code> 定义文字居中的样式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;p class=&quot;one&quot;&gt;我是less&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.center &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.red &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  .one &#123;</span><br><span class="line">    .center;</span><br><span class="line">    .red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>下面是带参数，且没有默认值的情况，<code>.color(@c)</code> 中的 <code>@c</code> 为需要传入的参数，如 <code>.color(green)</code> 传入绿色的颜色值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;p class=&quot;one&quot;&gt;我是less&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.center &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.color(@c) &#123;</span><br><span class="line">  color: @c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  .one &#123;</span><br><span class="line">    .center;</span><br><span class="line">    .color(green);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最后是带默认值的情况，<code>.color(@c: red)</code> 中的 <code>red</code> 为默认红色值，在不传参数的情况下，默认为红色，传入参数的则会覆盖 <code>red</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;p class=&quot;one&quot;&gt;我是less&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.center &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.color(@c: red) &#123;</span><br><span class="line">  color: @c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  .one &#123;</span><br><span class="line">    .center;</span><br><span class="line">    .color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在开发页面时，时常会有需要画三角形的情况，顶角分别对应上下左右四个方位的三角形，若是做重复劳动去绘制同样的三角形，显得不是那么优雅，这时候我们可以用到 Less 的匹配模式。 匹配模式下无论同名的哪一个混合（Mixin）被匹配到，都会先执行通用匹配模式的代码， <code>@_</code> 表示通用的匹配模式，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.triangle(@_, @width, @color) &#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-style: solid;</span><br><span class="line">&#125;</span><br><span class="line">// 上面的代码表示，在使用 .triangle 这个混合时，都会触发这三个属性。</span><br><span class="line">.triangle(Bottom, @width, @color) &#123;</span><br><span class="line">  border-width: @width;</span><br><span class="line">  border-color: @color transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(Left, @width, @color) &#123;</span><br><span class="line">  border-width: @width;</span><br><span class="line">  border-color: transparent @color transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(Top, @width, @color) &#123;</span><br><span class="line">  border-width: @width;</span><br><span class="line">  border-color: transparent transparent @color transparent;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(Right, @width, @color) &#123;</span><br><span class="line">  border-width: @width;</span><br><span class="line">  border-color: transparent transparent transparent @color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  p &#123;</span><br><span class="line">    .triangle(Left, 100px, red);</span><br><span class="line">  &#125;</span><br><span class="line">  // 传入 Left 100px red 这三个值，将会触发 .triangle(Left, @width, @color) 这个混合。</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>上述 Less 代码设置了基础的 <code>.triangle</code> 样式，再分别设置上下左右四个方位的匹配模式，并且可以通过 <code>@width</code> 参数来控制三角形大小。</p><p>arguments 变量：<code>@arguments</code> 表示 <code>.border(@width, @mode, @color)</code> 中的三个变量一起被赋值，代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.border(@width, @mode, @color) &#123;</span><br><span class="line">  border: @arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.one &#123;</span><br><span class="line">  .border(1px, solid, red);</span><br><span class="line">  // 等同于 border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Less-中的运算"><a href="#Less-中的运算" class="headerlink" title="Less 中的运算"></a>Less 中的运算</h2><p>算数运算符 +、-、*、/ 可以对任何数字、颜色或者变量进行运算，在 Less 中在加减之前会进行单位的换算。计算的结果以最左侧才作数的单位类型为准。如果单位无效或者失去意义，则单位会被忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width: 20px + 20; // 输出结果为 40px</span><br><span class="line">color: #444 * 2; // 输出结果为 #888888</span><br></pre></td></tr></table></figure><p><strong>calc() 特例</strong> <code>calc()</code> 是样式宽高的计算属性，为了与 CSS 保持兼容， <code>calc()</code> 方法并不会对数学表达式进行计算，但是在嵌套函数中会计算变量的数学公式的值。代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@a: 100vh/2 height: calc(50% + (@a - 40px)); // 输出结果为： calc(50% - (50vh - 40px))</span><br></pre></td></tr></table></figure><h2 id="Less-中的转译"><a href="#Less-中的转译" class="headerlink" title="Less 中的转译"></a>Less 中的转译</h2><p>转译，简单的理解就是我们原先是什么样的，最终输出的还是什么样。关键字是 <code>~&quot;&quot;</code>，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  color: ~&#x27;green&#x27;; // 编译后的输出结果还是 color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Less-中的作用域"><a href="#Less-中的作用域" class="headerlink" title="Less 中的作用域"></a>Less 中的作用域</h2><p>Less 中的作用域和 CSS 的作用域非常相似，首先 Less 会查询当前作用域内的变量，如果找不到的话会继续向上一级查询，直到找到为止。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@var: blur;</span><br><span class="line">body &#123;</span><br><span class="line">  @var: red;</span><br><span class="line">  .one &#123;</span><br><span class="line">    color: @var;</span><br><span class="line">    // @var 在 .one 中没有找到，会继续向上级 body 查找，最后找到 red 值。</span><br><span class="line">    // 编译后输出的结果为：color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Less-中的导入"><a href="#Less-中的导入" class="headerlink" title="Less 中的导入"></a>Less 中的导入</h2><p>现代前端开发，万物皆是模块。Less 也不例外，一个 Less 文件就可以当作一个模块来处理，一个 Less 文件中可以引入另外一个 Less 文件，并且可以使用里面的变量信息，我们来看实例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;p&gt;我是P&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">// 引入新建的 style.less 文件。</span><br><span class="line">@import &#x27;./style.less&#x27;;</span><br><span class="line"></span><br><span class="line">@color1: red;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  p &#123;</span><br><span class="line">    color: @color2;</span><br><span class="line">    // @color2 为引入的 style.less 中的变量。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 这是另一个 less 文件，需要新建。</span><br><span class="line">// style.less</span><br><span class="line">@color2: blue;</span><br></pre></td></tr></table></figure><p>在此建议，生命变量的时候，颜色主题可以单独创建一个 Less 文件。字体大小，文字粗细，阴影的大小，透明度等等也可以单独抽离一个 Less 文件，通过引入的方式全部引入到 index.less 中，在组件中使用的时候，可以只引入 index.less 文件，便可使用在 index.less 中引入的 Less 文件的变量。</p><h2 id="Less-实用实例"><a href="#Less-实用实例" class="headerlink" title="Less 实用实例"></a>Less 实用实例</h2><h3 id="文字超出省略"><a href="#文字超出省略" class="headerlink" title="文字超出省略"></a>文字超出省略</h3><p>这是前端开发中出现频率比较高的情况，我们来提取混合（Mixin），实例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 单行文字超出显示省略号</span><br><span class="line">.ellipsisSingle &#123;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来编写代码来验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;text&quot;&gt;</span><br><span class="line">        我是less我是less我是less我是less我是less我是less我是less</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.ellipsisSingle &#123;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  .text &#123;</span><br><span class="line">    .ellipsisSingle;</span><br><span class="line">    // .ellipsisSingle 为上述定义好的混合（Mixin）。</span><br><span class="line">    background: darkgoldenrod;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>多行省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.ellipsisMultiple(@num: 1) &#123;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  -webkit-line-clamp: @num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>styles 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  .text &#123;</span><br><span class="line">    .ellipsisMultiple(2);</span><br><span class="line">    background: darkgoldenrod;</span><br><span class="line">    width: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字垂直居中"><a href="#文字垂直居中" class="headerlink" title="文字垂直居中"></a>文字垂直居中</h3><p>很多时候你在写 CSS 样式的时候，会连续写两个连在一起的属性，比如 <code>height: 20px; line-height: 20px</code>，目的是为了让标签内的文字垂直居中，写多了就会觉得代码不是那么干净。又到了 Less 出手的时候了，把它封装起来，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;text&quot;&gt;我是less&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.line-text-h (@h: 0) &#123;</span><br><span class="line">  height: @h;</span><br><span class="line">  line-height: @h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  .text &#123;</span><br><span class="line">    .line-text-h(100px);</span><br><span class="line">    background: darkgoldenrod;</span><br><span class="line">    width: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="定位上下左右居中"><a href="#定位上下左右居中" class="headerlink" title="定位上下左右居中"></a>定位上下左右居中</h3><p>项目开发中有些场景比如设置空页面的图标上下左右居中，这时我们可以封装一个 Less 混合（Mixin）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;text&quot;&gt;我是less&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.center &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  .text &#123;</span><br><span class="line">    .center;</span><br><span class="line">    background: darkgoldenrod;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue学习</title>
      <link href="//b38a0bed.html"/>
      <url>//b38a0bed.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习一门新的框架语言，我个人认为最好的方式就是去它的官网把相应的生命周期以及 API 都用 Demo 的形式实操一遍。先学习vue的全局api的使用以及vue框架的生命周期，学习基础知识，包括vue常用命令，Mixin混入，vue生命周期函数。</p><p>vue的开发形式包括两种，包括script标签引入的方式，也包括脚手架启动web服务。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>在idea终端中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @vue/cli@4.1.1 -g</span><br></pre></td></tr></table></figure><p>下载完成之后，可以通过查看版本验证是否下载成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure><p>通过此脚手架建立一个vue项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create demo</span><br></pre></td></tr></table></figure><p>按照步骤，开始选择默认，下载选择npm即可新建项目，新建完成之后，我们需要修改一下配置，找到 <code>node_modules/@vue/cli-service/lib/options.js</code> 路径下该文件，直接在 devServer 中添加 <code>disableHostCheck: true</code> 。</p><div align='center'>  <img src='../images/a.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><p>通过下面命令启动demo项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd demo</span><br><span class="line">npm run serve //注意是serve，不是server；</span><br></pre></td></tr></table></figure><div align='center'>  <img src='../images/b.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><p>项目启动之后，访问localhost:8080出现下面这个画面表示配置成功。</p><div align='center'>  <img src='../images/c.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><p>找到src下的app.vue，即可在这个里面写代码，练习vue指令；</p><h1 id="指令练习"><a href="#指令练习" class="headerlink" title="指令练习"></a>指令练习</h1><h2 id="v-text-amp-amp-v-html"><a href="#v-text-amp-amp-v-html" class="headerlink" title="v-text &amp;&amp; v-html"></a>v-text &amp;&amp; v-html</h2><p>相同点：都能展示数据，且属于单向绑定，即数据的变化会影响插值的变化，而插值的变化，不会影响数据的变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实v-text也可以简写为&#123;&#123;&#125;&#125;。</span><br></pre></td></tr></table></figure><p>不同点：v-text只会渲染文本，浏览器不会对其中的html进行解析。v-html：用于输出html，浏览器会解析html。</p><p>下面举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; html &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p v-text=&quot;html&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#x27;大家好，我是赵盛超&#x27;,</span><br><span class="line">      html: &#x27;&lt;strong&gt;大家好，我是强壮的赵盛超&lt;/strong&gt;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><div align='center'>  <img src='../images/d.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第1、2行&#123;&#123;&#125;&#125;就是v-text，单纯输出文本，不会对文本解析，第3、4行同上。</span><br></pre></td></tr></table></figure><p>最后一行是v-html的会对html代码进行解析，当然也可以输出文本。</p><h2 id="v-if、v-else-amp-amp-v-show"><a href="#v-if、v-else-amp-amp-v-show" class="headerlink" title="v-if、v-else &amp;&amp; v-show"></a>v-if、v-else &amp;&amp; v-show</h2><p>相同点：通过变量控制标签内容的显示与隐藏</p><p>不同点：v-if在浏览器上表示为整个DOM节点不被渲染；v-show呈现的形式相当于给DOM节点在css样式上加了个  <strong>display:none</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p v-if=&quot;isshow&quot;&gt;条件成立显示这个&lt;/p&gt;</span><br><span class="line">&lt;p v-else&gt;否则显示这个&lt;/p&gt;</span><br><span class="line">&lt;p v-show=&quot;isshow&quot;&gt;true显示这个&lt;/p&gt;</span><br><span class="line">&lt;p v-show=&quot;!isshow&quot;&gt;false显示这个&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">isshow:true,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><div align='center'>  <img src='../images/e.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>v-for 指令解决的是模板循环渲染问题，没有 Vue、React 等框架之前都是通过 for 循环拼接字符串的形式，通过 append 将拼接好的节点塞入指定的 DOM 节点。现在有了 <code>v-for</code> 指令，就不用这么麻烦了，得到数组之后，只需以 <code>(item, index) in array</code> 的形式渲染数据。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;div v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123;index&#125;&#125;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">list:[&#x27;小红&#x27;,&#x27;小乐&#x27;,&#x27;小刚&#x27;],</span><br><span class="line">&#125;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div align='center'>  <img src='../images/f.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><p>index 数组对象所对应的索引值，渲染模版的时候如果需要做一些逻辑运算的时候，会用到这个索引值，比如只让索引值为偶数的项进行渲染，就可以结合之前的 <code>v-if</code>、<code>v-show</code> 指令去实现需求。</p><p><strong>小知识 1</strong>：<code>v-for</code> 和 <code>v-if</code> 不要一起使用</p><p><code>v-for</code> 的优先级高于 <code>v-if</code> ，当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环。比较好的解决方式是，先通过 <code>computed</code> 属性将需要渲染的列表提前过滤，再将过滤后的列表放到模板中渲染，这样做的目的是让页面渲染效率更高，避免不必要的资源浪费。</p><p><strong>小知识 2：</strong> <code>v-for</code> 可以渲染 Object 类型数据,比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;(val, key, index) in listObj&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">      &#123;&#123; index &#125;&#125;&#123;&#123; val.name &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      listObj: &#123;</span><br><span class="line">        hong: &#123;</span><br><span class="line">          name: &#x27;小红&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        ming: &#123;</span><br><span class="line">          name: &#x27;小明&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        zhi: &#123;</span><br><span class="line">          name: &#x27;小智&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        gang: &#123;</span><br><span class="line">          name: &#x27;小刚&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code> 就是监听事件，可以用 <code>v-on</code> 指令监听 DOM 事件来触发一些方法函数。</p><p><code>v-on</code> 有一种简写形式，用 @ 符号代替。它还能监听一些键盘事件，如键盘的回车键 <code>v-on:keyup.enter</code> 等，大家可以类推其他的键盘事件。</p><p>下面就来看看代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;数字:&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;</span><br><span class="line">&lt;input v-model=&quot;username&quot; v-on:keyup.enter=&quot;login&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">count:1,</span><br><span class="line">username:&quot; &quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods&#123;</span><br><span class="line">add()&#123;</span><br><span class="line">this.count++;</span><br><span class="line">&#125;,</span><br><span class="line">login()&#123;</span><br><span class="line">console.log(this.username);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>v-model</p><p>在 Vue 的众多指令里，<code>v-model</code> 算是举足轻重的，因为它的双向绑定特性，能解决很多业务上的复杂需求，下面就用几个小示例来诠释它的强大，代码演示如下：</p><p>1、最简单的双向绑定 (简单来说就是你输入什么，上面就跟你变)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;跟着输入变&#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;input v-model=&quot;username&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">username:&quot;&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2、结合复选框</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id =&quot;app&quot;&gt;</span><br><span class="line">&lt;label for=&quot;apple&quot;&gt;苹果&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;fruit.apple&quot; value=&quot;apple&quot;&gt;</span><br><span class="line">&lt;label for=&quot;orange&quot;&gt;橘子&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;fruit.orange&quot; value=&quot;orange&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&#123;&#123;fruit&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">fruit:&#123;</span><br><span class="line">apple:false,</span><br><span class="line">orange:false,</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>结合复选框实现切换复选框内的值，动态地改变数据</p><p>3、结合单选框</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;sex&quot; value=&quot;男&quot;&gt;</span><br><span class="line">&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;sex&quot; value=&quot;女&quot;&gt;</span><br><span class="line">&lt;p&gt;您选择的性别是:&#123;&#123;sex&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">sex:&quot;男&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="v-bind-、v-cloak、v-pre-amp-amp-v-once"><a href="#v-bind-、v-cloak、v-pre-amp-amp-v-once" class="headerlink" title="v-bind 、v-cloak、v-pre &amp;&amp; v-once"></a>v-bind 、v-cloak、v-pre &amp;&amp; v-once</h2><p>对变量属性的一个绑定，比如说需要绑定一个图片只需如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-bind:src=&quot;imgsrc&quot;&gt;</span><br><span class="line">可以简写</span><br><span class="line">&lt;img :src=&quot;imgsrc&quot;&gt;</span><br></pre></td></tr></table></figure><p>绑定 CSS 样式，一般用在需要计算表达式的时候使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class=&quot;classname&quot;&gt;綁定class&lt;/div&gt;</span><br><span class="line">// 判断变量</span><br><span class="line">&lt;div :class=&quot;&#123;classA: isShow&#125;&quot;&gt;绑定class中的判断&lt;/div&gt;</span><br><span class="line">// 三元运算符</span><br><span class="line">&lt;div :class=&quot;isShow ? classA : classB&quot;&gt;绑定class中的三元表达式判断&lt;/div&gt;</span><br><span class="line">// 绑定 style</span><br><span class="line">&lt;div :style=&quot;&#123;color: blue, fontSize: font&#125;&quot;&gt;绑定style&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>v-cloak</strong></p><p>作用：在使用双大括号赋值时，页面数据没有返回之前，页面会闪烁一下 <code>&#39;&quot;&#123;&#123;&#125;&#125;"'`双大括号，只需在全局样式下添加如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在绑定的变量节点上加上 ：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; v-cloak&gt;</span><br><span class="line">  &#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>试想用户打开网页，闪过一片 `&#123;&#123;parmas&#125;&#125;</code> ，不起眼的小指令，却极大的优化了网页的用户体验。</p><p><strong>v-pre</strong></p><p>直接跳过 Vue 的编译，输出原始值。在标签中如下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>最终在网页上输出的结果是 <code>&#123;&#123;message&#125;&#125;</code>。</p><p><strong>v-once</strong></p><p>只在第一次渲染时执行，之后的操作都被视为静态内容，跳出之后的所有渲染过程。</p><h1 id="Vue-directive-自定义组件"><a href="#Vue-directive-自定义组件" class="headerlink" title="Vue.directive 自定义组件"></a>Vue.directive 自定义组件</h1><p>之前也学了 <code>v-model</code>、<code>v-show</code> 等官方定义的指令，在项目的开发过程中，我们会有一些特殊的需求，要自定义指令，<code>Vue.directive</code> 就是为什么做这件事情的 API。比如自定義v-color指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//在app.vue中可以写</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p v-color=&quot;color&quot;&gt;颜色&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">color:&quot;red&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在main.js中添加下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&quot;color&quot;,function(el,binding,vnode)&#123;</span><br><span class="line">console.log(vnode);//必须用到vnode，不然会报错，三者缺一不可。</span><br><span class="line">el.style=&quot;color:&quot;+binding.value;</span><br><span class="line">&#125;);//注意Vue中的V需要大写</span><br></pre></td></tr></table></figure><h3 id="回调函数参数："><a href="#回调函数参数：" class="headerlink" title="回调函数参数："></a>回调函数参数：</h3><p>el：绑定的node节点；binding：包含指令信息的对象参数；vnode：vue编译生成的虚拟节点。</p><h3 id="自定义组件的生命周期"><a href="#自定义组件的生命周期" class="headerlink" title="自定义组件的生命周期"></a>自定义组件的生命周期</h3><p>自定义组件包含几个生命周期，也就是在调用自定义组件时，几个钩子函数会被触发，分别是如下。</p><ul><li>bind：只会调用一次，在第一次绑定到元素上时被调用，初始化操作可以使用它。</li><li>inserted：被绑定的元素插入了父节点。</li><li>update：被绑定的元素模板更新时调用。</li><li>componentUpdated：被绑定的元素模板完成一次生命周期。</li><li>unbind：指令和被绑定元素解绑时调用。</li></ul><h2 id="Vue-set全局操作"><a href="#Vue-set全局操作" class="headerlink" title="Vue.set全局操作"></a>Vue.set全局操作</h2><p>在解释 <code>Vue.set</code> 之前先了解一下 Vue 的响应式原理：</p><p>当你把一个 JS 对象传给 Vue 实例的 data 属性时，Vue 将遍历此对象的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本的浏览器。//没太明白。</p><h3 id="为什么要使用-Vue-set"><a href="#为什么要使用-Vue-set" class="headerlink" title="为什么要使用 Vue.set"></a>为什么要使用 Vue.set</h3><p>受限于现代浏览器，Vue 检测不到对象的添加和删除；因为 Vue 在初始化实例时对 <code>data</code> 属性执行 <code>getter/setter</code> 转化操作，所以对象必须在 <code>data</code> 中才能让其响应式。响应式思想是一种<strong>变化</strong>传递的思想，当数据<strong>变化</strong>后，会直接或者间接导致引用它的其他数据均发生相应的变化。</p><p><strong>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性，不过可以使用 <code>Vue.set</code> 方法将响应式属性添加到嵌套的对象上</strong>。代码演示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p v-for=&quot;(item,index) in fruit&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;button v-on:click=&quot;change&quot;&gt;变&lt;/div&gt;</span><br><span class="line">&#123;&#123;fruit&#125;&#125;</span><br><span class="line">&lt;button v-on:click=&quot;add&quot;&gt;设置&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name=&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">fruit:[&#x27;orange&#x27;,&#x27;apple&#x27;,&#x27;pear&#x27;],</span><br><span class="line">&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">change()&#123;</span><br><span class="line">this.fruit[1]=&quot;banana&quot;;</span><br><span class="line">&#125;</span><br><span class="line">add()&#123;</span><br><span class="line">this.$set(this.fruit,1,&#x27;banana&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue-filter"><a href="#Vue-filter" class="headerlink" title="Vue.filter"></a>Vue.filter</h2><p>全局过滤器是一个在项目中时常会用到的 API，使用场景也非常丰富，比如说数据的统计，保留小数点参数等等。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面我们演示一个简单的过滤器，需求是使用过滤器将需要过滤的目标值加上 4，代码演示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;count|sum&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&quot;app&quot;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">count:20,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">main.js:</span><br><span class="line">Vue.filter(&quot;sum&quot;,function(value)&#123;</span><br><span class="line">return value+4;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>屏幕上会出现 24 这个数字，注意的是，声明 sum 过滤器，必须要放在声明实例 app (export default?)之前，否则不会被注入到实例中。</p><h2 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h2><p>nextTick 是一个比较重要的高级特性，应用场景在很多地方会出现。Vue 是异步渲染的框架，一开始就是如此，当你改变 data 属性内部的变量，视图不会立即更新，在此时你若是进行 DOM 操作，是拿不到最新的渲染结果，这个时候你就要借助 Vue.nextTick 高级特性，在该特性的回调函数内获取最新的渲染结果。</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(function()&#123;</span><br><span class="line">//写在需要在某个操作改变dom结构</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Mixin-混入"><a href="#Mixin-混入" class="headerlink" title="Mixin 混入"></a>Mixin 混入</h2><p>混入（mixin）提供了一个非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包括任意组件选项。当组件使用混入对象时，所有混入对象的选项将被「混合」进入该组件本身的选项。文字有点难理解，通过举实例来解释 mixin 的具体用法。 其实我们可以用 Object 的思想去理解 mixin，假设有一个变量 A，它的值为 <code>&#123; a: 1, b: 2 &#125;</code>,有另一个变量 B，它的值为 <code>&#123; a: 3, c: 4 &#125;</code>,B 作为混入的对象混入 A，那么 A 中已有的属性 a 不会被覆盖，A 会新增一个 c 属性，最终 A 为 <code>&#123; a: 1, b: 2, c: 4 &#125;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//mixin.js</span><br><span class="line">export default&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">username:&quot;张三,</span><br><span class="line">age:30,</span><br><span class="line">haswife:true,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> mounted() &#123;</span><br><span class="line">    console.log(&#x27;mixin&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    speak() &#123;</span><br><span class="line">      console.log(&#x27;这是mixin&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    cry() &#123;</span><br><span class="line">      console.log(&#x27;这是cry&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">//app.vue</span><br><span class="line">import mixin from &#x27;./mixin&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      username: &#x27;李四&#x27;,</span><br><span class="line">      age: 31,</span><br><span class="line">      hasHusband: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#x27;app&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    speak() &#123;</span><br><span class="line">      console.log(&#x27;这是app&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    eat() &#123;</span><br><span class="line">      console.log(&#x27;吃饭&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">// 最终得到的结果如下</span><br><span class="line">export default&#123;</span><br><span class="line"> data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#x27;李四&#x27;, // name为共有属性，最终保留 app.vue 的</span><br><span class="line">      age: 31, // 同上</span><br><span class="line">      hasHusband: true, // app.vue 独有属性，保留</span><br><span class="line">      hasWife: true, // app.vue 没有的属性，会被添加进来</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 在钩子函数中的，会被合并到 app.vue 的钩子函数中，minix中的代码会在前面</span><br><span class="line">    console.log(&#x27;mixin&#x27;);</span><br><span class="line">    console.log(&#x27;app&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 两边都有的方法，会被封装为一个数组，先执行 minix 中的，后执行 app 自己的</span><br><span class="line">    speak() &#123;</span><br><span class="line">    [</span><br><span class="line">    function()&#123;</span><br><span class="line">     console.log(&#x27;这是mixin&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">function()&#123;</span><br><span class="line"> console.log(&#x27;这是app&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">    ].foreach((cb)=&gt;&#123;</span><br><span class="line">    cb();</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自身独有的，保留</span><br><span class="line">    eat() &#123;</span><br><span class="line">      console.log(&#x27;吃饭&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自身没有的方法，会被添加进来</span><br><span class="line">    cry() &#123;</span><br><span class="line">      console.log(&#x27;这是cry&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述为组件中使用 mixins 方法进行「混入」，下面我们来介绍「全局混入」，「混入」可以在入口页进行全局注册，但是使用它时要格外小心，一旦使用全局混入，它将会影响每一个之后创建的 Vue 实例。 官方示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。</span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    var myOption = this.$options.myOption;</span><br><span class="line">    if (myOption) &#123;</span><br><span class="line">      console.log(myOption);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  myOption: &#x27;hello!&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line">// =&gt; &quot;hello!&quot;</span><br></pre></td></tr></table></figure><h2 id="Vue-生命周期函数"><a href="#Vue-生命周期函数" class="headerlink" title="Vue 生命周期函数"></a>Vue 生命周期函数</h2><p>单页面开发模式，每个页面都可以理解为一个 Vue 组件，每个页面都是一个鲜活的生命，在它的一生中，从出生到消亡都会有对应的钩子函数，下面就让我们认识一下它们。</p><p>beforeCreate：在组件创建之前。</p><p>created：在组件创建之后，一般用于初始化一些固定的数据。</p><p>beforeMount：DOM 节点渲染之前。</p><p>mounted：在 DOM 节点渲染完之后被触发，通常笔者都会在这个生命周期中通过 ajax 去获取服务端的数据，如果在 created 生命周期里获取数据并渲染视图，DOM 节点可能还未被渲染，有可能页面会报错，安全起见，数据统一放在 mounted 钩子函数内获取。</p><p>beforeUpdate：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p><p>updated：当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 <a href="https://cn.vuejs.org/v2/api/#computed">计算属性</a> 或 <a href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之。</p><p>activated：被 keep-alive 缓存的组件激活时调用。</p><p>deactivated：被 keep-alive 缓存的组件停用时调用。</p><p>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</p><p>destroyed：实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。一般用于销毁页面内创建的 <code>setTimeout</code> 等变量，防止内存泄漏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-cloak&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;加+&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 1,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add: function () &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate: function () &#123;</span><br><span class="line">    console.log(&#x27;beforeCreate&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    console.log(&#x27;created&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount: function () &#123;</span><br><span class="line">    console.log(&#x27;beforeMount&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted: function () &#123;</span><br><span class="line">    console.log(&#x27;mounted&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate: function () &#123;</span><br><span class="line">    console.log(&#x27;beforeUpdate&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  updated: function () &#123;</span><br><span class="line">    console.log(&#x27;updated&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  activated: function () &#123;</span><br><span class="line">    console.log(&#x27;activated&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  deactivated: function () &#123;</span><br><span class="line">    console.log(&#x27;deactivated&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy: function () &#123;</span><br><span class="line">    console.log(&#x27;beforeDestroy&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed: function () &#123;</span><br><span class="line">    console.log(&#x27;destroyed&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue-Router-介绍及路由原理分析"><a href="#Vue-Router-介绍及路由原理分析" class="headerlink" title="Vue-Router 介绍及路由原理分析"></a>Vue-Router 介绍及路由原理分析</h1><p>单页面开发模式的路由全权交由前端来控制，这里的路由不是我们说的路由器等硬件设备，它是前端的路径管理器。而 Vue-Router 是官方提供的路由插件，市面上也不乏路由管理插件，但是只有 Vue-Router 能和 Vue 深度集成完美搭配。</p><h2 id="Vue-Router-路由模式"><a href="#Vue-Router-路由模式" class="headerlink" title="Vue-Router 路由模式"></a>Vue-Router 路由模式</h2><ul><li>单页面</li></ul><p>Vue 的单页面开发模式是基于组件和路由的配合，所有的页面均可视为组件，路由控制着访问路径，而每个路径映射一个组件。在单页模式中使用 a 标签做路由跳转是行不通的，因为本质上单页模式就只有一个 index.html 页面，所有的页面组件都在打包好的 JS 文件中，所以要使用 Vue-Router 的路由组件来跳转，这里的原因在后文中会有具体的例子解析。</p><ul><li>传统页面</li></ul><p>传统页面的开发模式，路由一般是由超链接（a 标签）来控制页面的跳转与切换，每次都会刷新整个页面，体验上不如单页模式。</p><p>Vue-Router 为我们提供了三种路由模式：</p><ul><li>Hash 模式</li><li>History 模式</li><li>abstract 模式</li></ul><h4 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h4><p>Hash 模式是 Vue-Router 的默认模式，具体的体现是在浏览器地址栏上 URL 路径永远带着一个「#」号。在浏览器支持度上面，Hash 模式是比较强势的，甚至能兼容低版本的 IE 浏览器。「#」号后面内容的改变，不会引起页面对服务端的请求，所以也就不会重新加载页面。在部署服务器方面，个人认为 Hash 模式比 History 模式来得更为方便，因为 History 有 URL 重定向问题，需要在服务端去配置 url 重定向，否则会报 404 错误。市面上也有不少大厂是使用 Hash 模式进行开发的，比如网易云音乐：</p><div align='center'>  <img src='../images/555.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><h4 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h4><p>HTML5 History API 提供了一个 history.pushState 和 history.reolaceState 方法（浏览器支持情况不是很乐观），它能让开发人员在不刷新网页的情况下改变站点的 URL。因为 Hash 模式会带上一个「#」号，会让 URL 地址变得比较难看，所以很多开发者都会选择 History 模式开发。但有个缺点，前端的 URL 必须和实际向服务端发起的请求的 URL 保持一致，如果服务端没有对相应的路由做处理，则会返回 404 错误页面。</p><h4 id="abstract-模式"><a href="#abstract-模式" class="headerlink" title="abstract 模式"></a>abstract 模式</h4><p>abstract 模式针对的是没有浏览器环境的情况，比如 Weex 客户端开发，内部是没有浏览器 API 的，那么 Vue-Router 自身会对环境做校验，强制切换到 abstract 模式，如果默认在 Vue-Router 的配置项中不写 mode 的值，在浏览器环境下会默认启用 Hash 模式，在移动客户端下使用 abstract 模式。</p><h2 id="Hash-模式原理"><a href="#Hash-模式原理" class="headerlink" title="Hash 模式原理"></a>Hash 模式原理</h2><p>大家常常会在浏览器上看到这样一种场景，点击某个文字，网页会跳转到某一个固定的位置，并且页面不会刷新。这便是浏览器的 a 标签锚点。Hash 模式被运用在了单页面开发的路由模式上，下面我们来简单实现一个通过 Hash 去控制页面组件的展示。 浏览器原生方法为我们提供了一个监听事件 <code>hashchange</code>，它能监听到的改变如下：</p><ul><li>点击 a 标签改变 URL 地址；</li><li>浏览器的前进后退行为；</li><li>通过 <code>window.location</code> 方法改变地址栏。</li></ul><p>以上三种情况都会触发 <code>hashchange</code> 监听事件，通过这个事件我们可以获取到 <code>localtion.hash</code>，继而去匹配相应的组件，下面是简易代码实现：</p><p>当初始的 HTML 文档被完全加载和解析完成之后， <code>DOMContentLoaded</code> 事件被触发，而无需等待样式表、图像和子框架的完成加载。 <code>hashchange</code> 不会被默认触发，所以网页首次加载完成后，需要默认执行一次 <code>hashchange</code> 监听方法要执行的函数 <code>HashChange</code>，当我点击代码中的两个 a 标签时，URL 地址栏改变触发 <code>hashchange</code> 事件， <code>HashChange</code> 方法通过拿到 <code>location.hash</code> 去匹配相应的组件（这里假设 page1、page2 为页面容器组件）。</p><p align='center'>    <iframe height="500" width="100%" autoplay="autoplay" controls="controls" allowfullscreen="true"src="//player.bilibili.com/player.html?aid=568199055&bvid=BV1Hv4y187Nd&cid=1046157062&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></p><h2 id="History-模式原理"><a href="#History-模式原理" class="headerlink" title="History 模式原理"></a>History 模式原理</h2><p>下面来介绍 History 模式。</p><p>通过 History 模式去控制路由，会遇到一些麻烦，根本原因是 History 模式利用的时候 <code>popstate</code> 监听事件无法监听到 <code>pushState</code>、 <code>replaceState</code>、a 标签这三种形式的变化，浏览器的前进后退是可以监听到。那么有什么好的解决方案吗？</p><blockquote><p>小知识：pushState 和 replaceState 都是 HTML5 的新 API，他们的作用很大，可以做到改变浏览器地址却不刷新页面。</p></blockquote><p>我们可以通过遍历页面上的所有 a 标签，阻止 a 标签的默认事件的同时，加上点击事件的回调函数，在回调函数内获取 a 标签的 href 属性值，再通过 <code>pushState</code> 去改变浏览器的 <code>location.pathname</code> 属性值。然后手动执行 <code>popstate</code> 事件的回调函数，去匹配相应的路由。逻辑上可能有些饶，我们用代码来解释一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;History 模式&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      // 下面为history的路由实现方式</span><br><span class="line">      window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load);</span><br><span class="line">      window.addEventListener(&#x27;popstate&#x27;, PopChange);</span><br><span class="line">      var routeView = null;</span><br><span class="line">      function Load() &#123;</span><br><span class="line">        routeView = document.getElementById(&#x27;route-view&#x27;);</span><br><span class="line">        PopChange();</span><br><span class="line">        // 获取所有带 href 属性的 a 标签节点</span><br><span class="line">        var aList = document.querySelectorAll(&#x27;a[href]&#x27;);</span><br><span class="line">        // 遍历 a 标签节点数组，阻止默认事件，添加点击事件回调函数</span><br><span class="line">        aList.forEach((aNode) =&gt;</span><br><span class="line">          aNode.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">            e.preventDefault(); //阻止a标签的默认事件</span><br><span class="line">            var href = aNode.getAttribute(&#x27;href&#x27;);</span><br><span class="line">            //  手动修改浏览器的地址栏</span><br><span class="line">            history.pushState(null, &#x27;&#x27;, href);</span><br><span class="line">            // 通过 history.pushState 手动修改地址栏，</span><br><span class="line">            // popstate 是监听不到地址栏的变化，所以此处需要手动执行回调函数 PopChange</span><br><span class="line">            PopChange();</span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      function PopChange() &#123;</span><br><span class="line">        console.log(&#x27;location&#x27;, location);</span><br><span class="line">        switch (location.pathname) &#123;</span><br><span class="line">          case &#x27;/page1&#x27;:</span><br><span class="line">            routeView.innerHTML = &#x27;page1&#x27;;</span><br><span class="line">            return;</span><br><span class="line">          case &#x27;/page2&#x27;:</span><br><span class="line">            routeView.innerHTML = &#x27;page2&#x27;;</span><br><span class="line">            return;</span><br><span class="line">          default:</span><br><span class="line">            routeView.innerHTML = &#x27;page1&#x27;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="路由使用"><a href="#路由使用" class="headerlink" title="路由使用"></a>路由使用</h2><h3 id="引入-Vue-Router"><a href="#引入-Vue-Router" class="headerlink" title="引入 Vue-Router"></a>引入 Vue-Router</h3><p>首先是 HTML，我们引入 Vue 和 Vue Router 的静态资源，大家可以去 <a href="https://www.bootcdn.cn/">BootCDN</a> 搜索自己需要的静态资源，下面是 HTML 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;title&gt;Vue Router&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;!-- 使用 router-link 组件来导航. --&gt;</span><br><span class="line">        &lt;!-- 通过传入 to 属性指定链接. --&gt;</span><br><span class="line">        &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &lt;a&gt; 标签 --&gt;</span><br><span class="line">        &lt;router-link to=&quot;/page1&quot;&gt;Go to Page1&lt;/router-link&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;router-link to=&quot;/page2&quot;&gt;Go to Page2&lt;/router-link&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;!-- 路由出口 --&gt;</span><br><span class="line">      &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      // 1. 定义 (路由) 组件。</span><br><span class="line">      // 可以从其他文件 import 进来，这里简单写</span><br><span class="line">      const Page1 = &#123; template: &#x27;&lt;div&gt;Page1&lt;/div&gt;&#x27; &#125;;</span><br><span class="line">      const Page2 = &#123; template: &#x27;&lt;div&gt;Page2&lt;/div&gt;&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">      // 2. 定义路由</span><br><span class="line">      // 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</span><br><span class="line">      // 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">      // 或者，只是一个组件配置对象。</span><br><span class="line">      const routes = [</span><br><span class="line">        &#123; path: &#x27;/page1&#x27;, component: Page1 &#125;,</span><br><span class="line">        &#123; path: &#x27;/page2&#x27;, component: Page2 &#125;,</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      // 3. 创建 router 实例，然后传 routes 配置</span><br><span class="line">      // 你还可以传别的配置参数, 不过先这么简单着吧。</span><br><span class="line">      const router = new VueRouter(&#123;</span><br><span class="line">        routes: routes,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      // 4. 创建和挂载根实例。</span><br><span class="line">      // 记得要通过 router 配置参数注入路由，</span><br><span class="line">      // 从而让整个应用都有路由功能</span><br><span class="line">      const app = new Vue(&#123;</span><br><span class="line">        router: router,</span><br><span class="line">      &#125;).$mount(&#x27;#app&#x27;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;router-view&gt;</code> 标签和 <code>&lt;router-link&gt;</code> 标签是引入 Vue-Router 后才能使用的，路由匹配到的组件都会渲染在 <code>&lt;router-view&gt;</code> 标签上， <code>&lt;router-link&gt;</code> 标签用于路由的跳转。</p><p>Vue-Router 默认启动 Hash 模式，同样复制到 index.js，重启 <code>node app.js</code> 启动页面的时候，会看到如下所示：</p><h3 id="获取全局路由跳转参数的变化"><a href="#获取全局路由跳转参数的变化" class="headerlink" title="获取全局路由跳转参数的变化"></a>获取全局路由跳转参数的变化</h3><p>想要全局监听路由的变化，可以在入口页面通过 watch <code>$router</code>对象来实现，修改上述代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  ...</span><br><span class="line">   // 4. 创建和挂载根实例。</span><br><span class="line">   // 记得要通过 router 配置参数注入路由，</span><br><span class="line">   // 从而让整个应用都有路由功能。</span><br><span class="line">   const app = new Vue(&#123;</span><br><span class="line">     router: router,</span><br><span class="line">     watch: &#123;</span><br><span class="line">       $route(to, from) &#123;</span><br><span class="line">         console.log(&#x27;to&#x27;, to)</span><br><span class="line">         console.log(&#x27;from&#x27;, from)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line">   ...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>添加监听之后，可以拿到 to 和 from 两个参数，to 代表你跳转后的页面参数，from 代表你从哪个页面跳转来的，通过拿到这两个参数，我们就能设置一级二级页面，用于制作过场动画。也可以添加页面顶部的页面加载进度条。</p><h3 id="获取路由中带的参数"><a href="#获取路由中带的参数" class="headerlink" title="获取路由中带的参数"></a>获取路由中带的参数</h3><p>Page1 页面在跳转的时候带上参数到 Page2，我们如何在 Page2 拿到参数呢？首先我们要给 <code>router-link</code> 标签添加参数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;path: &#x27;/page1&#x27;, query: &#123; id: 1111 &#125;&#125;&quot;</span><br><span class="line">  &gt;Go to Page1&lt;/router-link</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在 Page1 的模板页面拿到参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Page1 = &#123; template: &#x27;&lt;div&gt;Page1 &#123;&#123; $route.query.id &#125;&#125;&lt;/div&gt;&#x27; &#125;;</span><br></pre></td></tr></table></figure><h3 id="重定向页面"><a href="#重定向页面" class="headerlink" title="重定向页面"></a>重定向页面</h3><p>这点还是比较重要的，当你输入一个不存在的路由，Vue-Router 无法匹配到的时候，需要默认回到首页，这就要用到重定向匹配，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123; path: &#x27;/page1&#x27;, component: Page1 &#125;,</span><br><span class="line">  &#123; path: &#x27;/page2&#x27;, component: Page2 &#125;,</span><br><span class="line">  &#123; path: &#x27;*&#x27;, redirect: &#x27;/page1&#x27; &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这里我们默认 Page1 为首页，当 <code>*</code> 上面的路径都没有被匹配到的时候，就会重新回到 <code>/page1</code> 对应的组件。</p><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>本章节通过理论知识学习 Vuex 全局状态管理，理解 Vuex 工作原理的同时，通过小例子实践 Vuex 的使用。</p><h2 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么"></a>Vuex 是什么</h2><p>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><p>笔者个人理解，一句即可以概括： <strong>Vuex 是用于管理 Vue 应用跨组件数据的工具。</strong></p><p>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><p>笔者个人理解，一句即可以概括： <strong>Vuex 是用于管理 Vue 应用跨组件数据的工具。</strong></p><blockquote><p>跨组件数据指的是，在 A、B、C 组件都需要用到的数据，比如购物车的数量，在很多页面是需要用到的。</p></blockquote><h2 id="Vuex-如何存储数据"><a href="#Vuex-如何存储数据" class="headerlink" title="Vuex 如何存储数据"></a>Vuex 如何存储数据</h2><p>说起这个还真有很多同学对 Vuex 的存储概念比较模糊，那么下面我们来分析一下 Vuex 和 localStorage、sessionStorage 在存储上的区别。</p><ul><li>Vuex</li></ul><p>Vuex 存储在浏览器内存，它采用的是集中式存储管理应用的所有组件的状态，在不刷新网页的情况下，状态会一直保持，一旦刷新网页，所有状态都将会重制。</p><ul><li>sessionStorage</li></ul><p>sessionStorage 是一种会话型存储，用于保存同一窗口或标签页的数据，数据保存在浏览器本地，在关闭窗口或标签页之后将会删除这些数据，这就是会话型存储，就跟人于人说话一样，人走了对话就结束了。</p><ul><li>localStorage</li></ul><p>localStorage 是一种持久性存储，与 sessionStorage 的功能近乎相似，但是在数据的存储时长上有所区别。它可以让数据一直存在于浏览器本地，除非你主动的 clear 数据，或者重装浏览器。</p><p>很多同学会认为既然 localStorage 存储时效这么强大，为什么不能用它去代替 Vuex 管理应用的数据呢？当然，在某些场景下，数据存在 localStorage 是比较合适的，像一些不需要变化的数据。但是在 Vue 单页应用开发中，两个组件 A 和 B 共用一份数据，B 若是能响应 A 对数据的改动，这种情况下 localStorage 和 sessionStorage 就显得比较乏力，毕竟 Vuex 有一整套高度兼容 Vue.js 开发模式的结构。</p><h2 id="Vuex-核心概念"><a href="#Vuex-核心概念" class="headerlink" title="Vuex 核心概念"></a>Vuex 核心概念</h2><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>什么是单向数据流呢？它指的是通过一定的规则去改变数据，数据触发视图的更新，通过视图中的方法去触发数据的更新，形成一个闭环。如下图所示：</p><div align='center'>  <img src='../images/333.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div><p>但事与愿违，复杂应用里会遇到多个组件共享同状态，不同视图的行为变更同一个状态等等问题，这时单向数据流就会被破坏。</p><p>Vuex 的出现就是为了解决这类复杂场景应用，那么我们在看看一张官方提供的流程图：</p><p><div align='center'>  <img src='../images/444.png' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'></p></div></p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue+springboot实现的全栈商城项目</title>
      <link href="//4f33e005.html"/>
      <url>//4f33e005.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目录结构释义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Lmall-api</span><br><span class="line">    ├── src/main/java</span><br><span class="line">         └── com.Lmall</span><br><span class="line">                 ├── common // 存放相关的常量配置及枚举类</span><br><span class="line">                 ├── config // 存放 web 配置类</span><br><span class="line">                 ├── api // 存放控制类，包括所有的 API 处理类</span><br><span class="line">                   ├── param // 存放请求时的参数实体</span><br><span class="line">                     └──  vo // 存放接口响应返回给前端的 view object 实体</span><br><span class="line">                 ├── dao // 存放数据层接口</span><br><span class="line">                 ├── entity // 存放实体类</span><br><span class="line">                 ├── service // 存放业务层方法</span><br><span class="line">                 ├── util // 存放工具类</span><br><span class="line">                 └── LouMallAPIApplication // Spring Boot 项目主类</span><br><span class="line">    ├── src/main/resources</span><br><span class="line">         ├── mapper // 存放 MyBatis 的通用 Mapper文件</span><br><span class="line">         ├── application.properties // 项目配置文件</span><br><span class="line">         └── Lmall_db_v2_schema.sql // 项目所需的 SQL 文件</span><br><span class="line">    └── pom.xml // Maven 配置文件</span><br></pre></td></tr></table></figure><p>前后端分离开发模式中，后端开发者主要就是提供前端页面所需的接口，该项目提供了楼楼商城 Vue 项目所需要的全部接口，接口文档的生成是使用 Swagger，启动后大家也会看到所有的接口类。</p><p>除了 Spring Boot 项目的基础目录外，我还在 <code>resources</code> 目录中上传了 <code>Lmall_db_v2_schema.sql</code> 文件，这是项目启动时所需的数据库文件，<code>Lmall_db_v2_schema.sql</code> 是商城项目的 SQL 文件，包含了项目所需的所有表结构和初始化数据。</p><p><code>Lmall-goods-pic.zip</code> 文件则是商品图片文件，我在商品表中存储了数百条记录，主要是为了大家可以更好的学习和体验，这些数据的图片文件就是 <code>Lmall-goods-pic.zip</code> 这个压缩包，如果没有这个压缩包，你在启动项目后看到所有页面的商品图片都是 404，这并不是一个很好的学习体验，这两个文件的作用即是如此，后面我会继续介绍它们的使用和配置。</p><h2 id="登录功能介绍"><a href="#登录功能介绍" class="headerlink" title="登录功能介绍"></a>登录功能介绍</h2><h4 id="什么是登录"><a href="#什么是登录" class="headerlink" title="什么是登录"></a>什么是登录</h4><p>这里说的是互联网范畴的登录，通常供多人使用的网站或程序应用系统为每位用户配置了一套独特的用户名和密码，用户可以使用各自的用户名和密码进入系统，以便系统能识别该用户的身份，从而保持该用户的使用习惯或使用数据。用户使用这套用户名和密码进入系统，以及系统验证进入是成功或失败的过程，称为 “ 登录 ” 。</p><p><img src="https://doc.shiyanlou.com/courses/2573/358858/a64879d6f875c46c134b2671165cb951-0" alt="img"></p><p>登录成功之后，用户就可以合法地使用该账号具有的各项能力，例如，淘宝用户可以正常浏览商品和完成购买行为等；论坛用户可以查看/更改资料，收发帖子等等；OA 等系统管理员用户可以正常地处理各种数据和信息，从最简单的角度来说就是输入你的用户名和密码就可以进入一个 “ 系统 ” 进行访问和操作了。</p><h4 id="用户登录状态"><a href="#用户登录状态" class="headerlink" title="用户登录状态"></a>用户登录状态</h4><p>客户端（通常是浏览器）在连上 Web 服务器后，若想获得 Web 服务器中的各种资源，需要遵守一定的通讯格式。Web 项目通常使用的是 HTTP 协议，HTTP 协议用于定义客户端与 Web 服务器通讯的格式。而 HTTP 协议又是无状态的协议，也就是说，这个协议是无法记录用户访问状态的，其每次请求都是独立的没有任何关联的，一个请求就是一个请求。</p><p>以商城项目为例，在楼楼商城 Vue 版本中包括多个页面，在页面跳转过程中和通过接口进行数据交互时我们需要知道用户的状态，尤其是用户登录的状态，以便我们知道这是否是一个正常的用户，这个用户是否处于合法的登录状态，这样才能在页面跳转和接口请求时知道是否可以让当前用户来操作一些功能或是获取一些数据。</p><p>因此需要在每个页面对用户的身份进行验证和确认，但现实情况是，不可能让用户在每个页面上都输入用户名和密码，这是一个多么反人类的设计啊，应该不会有用户想要去使用这种系统，所以在设计时，要求用户进行一次登录操作即可。为了实现这一功能就需要一些辅助技术，用得最多的技术就是浏览器的 Cookie，而在 Java Web 开发中，用的比较多的是 Session，将用户登录的信息存放其中，这样就可以通过读取 Cookie 或者 Session 中的数据获得用户的登录信息，从而达到记录状态、验证用户这一目的。</p><h4 id="用户眼中的登录"><a href="#用户眼中的登录" class="headerlink" title="用户眼中的登录"></a>用户眼中的登录</h4><p>用户系统是很多产品最基础的构成之一，在设计和规划系统时首先应该想到的就是登录功能，账号密码优先是最常见的一种登录注册设计，适用于普遍场景，这种方式也有利于产品引导用户完善更多的资料，留存自己的用户信息。淘宝以淘宝账号密码登录为最优先，京东则以京东账号密码登录为最优先，知乎也是以账号密码登录为最优先，且会隐藏第三方授权登录，QQ 是以 QQ 号和密码为登录形式。</p><p>由身边比较常用的例子也可以看出账密登录是多么普遍的形式，账号可以是用户名，可以是手机号，可以是 QQ 号码等多种形式，但是最终在功能实现中它们都被称作账号，账号+密码构成了最常见的登录形式。</p><p><img src="https://doc.shiyanlou.com/courses/2573/358858/db5527e16e5fc329da89618f06d0b3e3-0" alt="taobao-login-page"></p><h2 id="登录流程设计"><a href="#登录流程设计" class="headerlink" title="登录流程设计"></a>登录流程设计</h2><h4 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h4><p>通过前文的叙述也可以得出登录的本质，即身份验证和登录状态的保持，在实际编码中是如何实现的呢？</p><p>首先，在数据库中查询这条用户记录，伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx_user where account_number=&#x27;xxxx&#x27;; </span><br></pre></td></tr></table></figure><p>如果不存在这条记录则表示身份验证失败，登录流程终止；如果存在这条记录，则表示身份验证成功，接下来则需要进行登录状态的存储和验证了，存储伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//通过cookie存储</span><br><span class="line">Cookie cookie = new Cookie(&quot;username&quot;,xxxx);</span><br><span class="line">//通过session存储</span><br><span class="line">session.setAttribute(&quot;username&quot;,xxxx);</span><br></pre></td></tr></table></figure><p>验证逻辑的伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//通过cookie获取需要验证的数据并进行对比</span><br><span class="line">Cookie cookies[] = request.getCookies();</span><br><span class="line">if(cookies!=null)&#123;</span><br><span class="line">for (int i =0;i&lt;cookies.length;i++)&#123;</span><br><span class="line">Cookie cookie = cookies[i];</span><br><span class="line">if(name.equals(cookie.getName()))</span><br><span class="line">return cookie;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过session获取需要验证的数据并进行对比</span><br><span class="line">session.getAttribute(&quot;username&quot;);</span><br></pre></td></tr></table></figure><p>以上就是通用的登录流程设计。</p><p>登录的本质就是身份验证和登录状态的保持，不过还有一点不能忽略，就是登录功能的安全验证设计，一般的做法是将密码加密存储，不过千万不要在 Cookie 中存放用户密码，加密的密码也不行。因为这个密码可以被人获取并尝试离线穷举，同样的，有些网站会在 Cookie 中存储一些用户的其他敏感信息，这些都是不安全的行为。</p><p>在本课程的实战项目中将对登录功能进行优化改造，通过生成用户令牌 Token 的形式进行用户状态的保持和验证，简单理解起来的话，这里所说的 Token 就是后端生成的一个字符串，该字符串与用户信息做关联，Token 字符串通过一些无状态的数据生成并不包含用户敏感信息。</p><p>简版流程图如下：</p><p><img src="https://doc.shiyanlou.com/courses/2573/358858/645043f139cb9f51f1b930bc7c155e9e-0" alt="login-check-simple"></p><p>当然，还有一些验证操作是必须的，比如前端在发送数据时需要验证数据格式及有效性，后端接口在访问之前也需要验证用户信息是否有效，因此完整版的登录验证流程如下：</p><p><img src="https://doc.shiyanlou.com/courses/2573/358858/a3b52522a98919159bea7a1f46b54d02-0" alt="login-check-detail"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文章接口</title>
      <link href="//ef4ef658.html"/>
      <url>//ef4ef658.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="数据库学习"><a href="#数据库学习" class="headerlink" title="数据库学习"></a>数据库学习</h2><h2 id="java学习"><a href="#java学习" class="headerlink" title="java学习"></a>java学习</h2><h2 id="django框架学习"><a href="#django框架学习" class="headerlink" title="django框架学习"></a>django框架学习</h2><h2 id="springboot学习"><a href="#springboot学习" class="headerlink" title="springboot学习"></a>springboot学习</h2><h2 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h2><h2 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h2><h2 id="react3学习"><a href="#react3学习" class="headerlink" title="react3学习"></a>react3学习</h2><h2 id="html-css-js-vue3学习"><a href="#html-css-js-vue3学习" class="headerlink" title="html css js vue3学习"></a>html css js vue3学习</h2><h2 id="git仓库练习"><a href="#git仓库练习" class="headerlink" title="git仓库练习"></a>git仓库练习</h2><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="python-django-docker实现的网上电子签约系统"><a href="#python-django-docker实现的网上电子签约系统" class="headerlink" title="python+django+docker实现的网上电子签约系统"></a>python+django+docker实现的网上电子签约系统</h2><h2 id="python-django-docker实现的网页小游戏"><a href="#python-django-docker实现的网页小游戏" class="headerlink" title="python+django+docker实现的网页小游戏"></a>python+django+docker实现的网页小游戏</h2><h2 id="vue-springboot实现的全栈商城项目"><a href="#vue-springboot实现的全栈商城项目" class="headerlink" title="vue+springboot实现的全栈商城项目"></a>vue+springboot实现的全栈商城项目</h2><h2 id="html-css-javascript实现的拳皇小游戏"><a href="#html-css-javascript实现的拳皇小游戏" class="headerlink" title="html+css+javascript实现的拳皇小游戏"></a>html+css+javascript实现的拳皇小游戏</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java语言</title>
      <link href="//b25fd2c7.html"/>
      <url>//b25fd2c7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><p>常量 使用final修饰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int N = 110;类似于c++中的const，定义之后就不能修改了。</span><br></pre></td></tr></table></figure><p>显示转化：int x = (int)’A’;<br>隐式转化：double x = 12, y = 4 * 3.3;</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>两种输入方式，包括Scanner以及BufferedRead，区别在于Scanner用于数据量小的，bufferedread用于数据量大的。<strong>使用bufferedread时注意要throws exception。</strong>下面两个样例介绍Scanner以及BufferedRead的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">public string void main(String[] args)&#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int x = sc.nextInt();</span><br><span class="line">double y = sc.nextDouble();</span><br><span class="line">float z = sc.nextFloat();</span><br><span class="line">string line = sc.nextLine();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用传递<br>除String以外的数据类型的对象，例如数组、StringBuilder等采用引用传递。将实参的引用（地址）传给形参，通过引用找到变量的真正地址，然后对地址中的值修改。所以此时对形参的修改会影响实参的初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedRead;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">public class Main&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">BufferedRead br = new BufferedRead(new InputStreamReader(System.in));</span><br><span class="line">int x = br.readLine();</span><br><span class="line">string str = br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出与输入一样有两种方式：包括sout以及BufferedWriter, sout用于输出规模较小时，BufferedWriter用于输出规模大的时候；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf()的用法类似于c语言中的printf，需要加%d,%f之类的。</span><br><span class="line">System.out.print()可直接输出，与System.out.println()的区别就在于第二个有回车换行；</span><br></pre></td></tr></table></figure><p><strong>第二种注意要加flush（）函数进行刷新。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));</span><br><span class="line">        bw.write(&quot;Hello World\n&quot;);</span><br><span class="line">        bw.flush();  // 需要手动刷新缓冲区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环与判断与c++类似，不在这多做赘述。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组定义与变量类似，比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] a = new int[10];</span><br><span class="line">float[] b = new float[20];</span><br><span class="line">char[] c = new char[12];</span><br></pre></td></tr></table></figure><p>多维数组的定义方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[][] aa = new int[10][10];</span><br><span class="line">float[][] bb = new float[20][20];</span><br></pre></td></tr></table></figure><p>数组常用api：1.属性length，返回数组的长度，比如a.length();</p><p>2.数组排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort()；</span><br></pre></td></tr></table></figure><p>3.填充数组,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(int[] a,int val);</span><br></pre></td></tr></table></figure><p>4.将数组转化成字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString()；</span><br></pre></td></tr></table></figure><p>5.将多维数组转化成字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.deepToString();</span><br></pre></td></tr></table></figure><p>6.数组是不可变长的。使用Arrays的api需要 import   java.utils.Arrays;</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符与整数的联系——ASCII码<br>每个常用字符都对应一个-128 ~ 127的数字，二者之间可以相互转化。<strong>注意：目前负数没有与之对应的字符。</strong><br>常用ASCII值：’A’- ‘Z’是65 ~ 90，’a’ - ‘z’是97 - 122，0 - 9是 48 - 57。<br>字符可以参与运算，运算时会将其当做整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = &#x27;B&#x27; - &#x27;A&#x27;;</span><br><span class="line">        int b = &#x27;A&#x27; * &#x27;B&#x27;;</span><br><span class="line">        char c = &#x27;A&#x27; + 2;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String类，初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;Hello World&quot;;</span><br><span class="line">String b = &quot;My name is &quot;;</span><br><span class="line">String x = b;  // 存储到了相同地址，x和b指向同一地址。</span><br><span class="line">String c = b + &quot;yxc&quot;;  // String可以通过加号拼接</span><br><span class="line">String d = &quot;My age is &quot; + 18;  // int会被隐式转化成字符串&quot;18&quot;</span><br><span class="line">String str = String.format(&quot;My age is %d&quot;, 18);  // 格式化字符串，类似于C++中的sprintf</span><br><span class="line">String money_str = &quot;123.45&quot;;</span><br><span class="line">double money = Double.parseDouble(money_str);  // String转double</span><br><span class="line">只读变量，不能修改，例如：</span><br><span class="line"></span><br><span class="line">String a = &quot;Hello &quot;;</span><br><span class="line">a += &quot;World&quot;;  // 会构造一个新的字符串</span><br><span class="line">访问String中的字符：</span><br><span class="line"></span><br><span class="line">String str = &quot;Hello World&quot;;</span><br><span class="line">for (int i = 0; i &lt; str.length(); i ++ ) &#123;</span><br><span class="line">    System.out.print(str.charAt(i));  // 只能读取，不能写入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">length()：返回长度</span><br><span class="line">split(String regex)：分割字符串</span><br><span class="line">indexOf(char c)、indexOf(String str)、lastIndexOf(char c)、lastIndexOf(String str)：查找，找不到返回-1</span><br><span class="line">equals()：判断两个字符串是否相等，注意不能直接用==</span><br><span class="line">compareTo()：判断两个字符串的字典序大小，负数表示小于，0表示相等，正数表示大于</span><br><span class="line">startsWith()：判断是否以某个前缀开头</span><br><span class="line">endsWith()：判断是否以某个后缀结尾</span><br><span class="line">trim()：去掉首尾的空白字符</span><br><span class="line">toLowerCase()：全部用小写字符</span><br><span class="line">toUpperCase()：全部用大写字符</span><br><span class="line">replace(char oldChar, char newChar)：替换字符</span><br><span class="line">replace(String oldRegex, String newRegex)：替换字符串</span><br><span class="line">substring(int beginIndex, int endIndex)：返回[beginIndex, endIndex)中的子串</span><br><span class="line">toCharArray()：将字符串转化成字符数组</span><br></pre></td></tr></table></figure><p>StringBuilder、StringBuffer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String不能被修改，如果打算修改字符串，可以使用StringBuilder和StringBuffer。</span><br><span class="line"></span><br><span class="line">StringBuffer线程安全，速度较慢；StringBuilder线程不安全，速度较快。</span><br><span class="line"></span><br><span class="line">StringBuilder sb = new StringBuilder(&quot;Hello &quot;);  // 初始化</span><br><span class="line">sb.append(&quot;World&quot;);  // 拼接字符串</span><br><span class="line">System.out.println(sb);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; sb.length(); i ++ ) &#123;</span><br><span class="line">    sb.setCharAt(i, (char)(sb.charAt(i) + 1));  // 读取和写入字符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sb);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常用 api:   reverse()：翻转字符串</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>一个典型的函数定义包括以下部分：修饰符、返回类型、函数名字、由0个或多个形参组成的列表以及函数体。</p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>public class Main &#123;    private static int fact(int val) &#123;        int res = 1;        for (int i = 1; i &lt;= val; i ++ )            res *= i;        return res;    &#125;    public static void main(String[] args) &#123;    int res = fact(5);    System.out.printf(&quot;5! is %d\n&quot;, res); &#125;&#125;</code></pre><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。</p><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，依次类推。形参和实参的类型和个数必须匹配。</p><p>函数的形参列表可以为空，但是不能省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void f1() &#123;/* …. */&#125;            // 空形参列表</span><br><span class="line">形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：</span><br><span class="line"></span><br><span class="line">int f3(int v1, v2) &#123;/* … */&#125;        // 错误</span><br><span class="line">int f4(int v1, int v2) &#123;/* … */&#125;    // 正确</span><br></pre></td></tr></table></figure><h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。<br>函数的返回类型也可以是数组、字符串或者其他对象：</p><pre><code>import java.util.Arrays;public class Main &#123;    private static int[] newArray() &#123;        int[] a = &#123;1, 2, 3&#125;;        return a;    &#125;    private static String newString() &#123;    return &quot;Hello World&quot;;&#125;    public static void main(String[] args) &#123;    System.out.println(Arrays.toString(newArray()));    System.out.println(newString());&#125;</code></pre><p>}</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>函数内定义的变量为局部变量，只能在函数内部使用。<br>定义在类中的变量为成员变量，可以在类的所有成员函数中调用。<br>当局部变量与全局变量重名时，会优先使用局部变量。</p><pre><code>public class Main &#123;    private static int x = 4;    private static void f1() &#123;    int x = 3;    System.out.println(x);//输出3&#125;    private static void f2() &#123;    System.out.println(x);//输出4&#125;    private static void f3() &#123;    System.out.println(x + 1);//输出5&#125;    public static void main(String[] args) &#123;    f1();    f2();    f3();&#125;&#125;</code></pre><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>八大基本数据类型和String类型等采用值传递。将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。</p><pre><code>public class Main &#123;    private static void f(int x) &#123;        x = 5;    &#125;    public static void main(String[] args) &#123;    int x = 10;    f(x);    System.out.println(x);&#125;&#125;import java.util.Arrays;public class Main &#123;    private static void f1(int[] a) &#123;        for (int i = 0, j = a.length - 1; i &lt; j; i ++, j -- ) &#123;            int t = a[i];            a[i] = a[j];            a[j] = t;        &#125;    &#125;    private static void f2(StringBuilder sb) &#123;    sb.append(&quot;Hello World&quot;);&#125;    public static void main(String[] args) &#123;    int[] a = &#123;1, 2, 3, 4, 5&#125;;    f1(a);    System.out.println(Arrays.toString(a));    StringBuilder sb = new StringBuilder(&quot;&quot;);    f2(sb);    System.out.println(sb);&#125;</code></pre><h3 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h3><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return语句有两种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return;</span><br><span class="line">return expression;</span><br></pre></td></tr></table></figure><p>无返回值函数<br>没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。通常情况下，void函数如果想在它的中间位置提前退出，可以使用return语句。return的这种用法有点类似于我们用break语句退出循环。</p><pre><code>public class Main &#123;    private static void swap(int[] a) &#123;  // 交换a[0]和a[1]        // 如果两个值相等，则不需要交换，直接退出        if (a[0] == a[1])            return;        // 如果程序执行到了这里，说明还需要继续完成某些功能    int tmp = a[0];    a[0] = a[1];    a[1] = tmp;    // 此处无须显示的return语句&#125;    public static void main(String[] args) &#123;    int[] a = &#123;3, 4&#125;;    swap(a);    System.out.printf(&quot;%d %d\n&quot;, a[0], a[1]);&#125;&#125;</code></pre><p>3.2 有返回值的函数<br>只要函数的返回类型不是void，则该函数内的每个分支都必须有return语句，且每条return语句都必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换函数的返回类型。</p><pre><code>import java.util.Scanner;public class Main &#123;    private static int max(int a, int b) &#123;        if (a &gt; b)            return a;        return b;    &#125;    public static void main(String[] args) &#123;    Scanner sc = new Scanner(System.in);    int x = sc.nextInt(), y = sc.nextInt();    System.out.println(max(x, y));&#125;&#125;</code></pre><p>函数重载<br>函数重载是指：在同一个类中存在多个函数，函数名称相同但参数列表不同。编译器会根据实参的类型选择最匹配的函数来执行。</p><pre><code>import java.util.Scanner;public class Main &#123;    private static int max(int a, int b) &#123;        System.out.println(&quot;int max&quot;);        if (a &gt; b) return a;        return b;    &#125;    private static double max(double a, double b) &#123;    System.out.println(&quot;double max&quot;);    if (a &gt; b) return a;    return b;&#125;    public static void main(String[] args) &#123;    System.out.println(max(3, 4));    System.out.println(max(3.0, 4.0));&#125;&#125;</code></pre><ol><li><p>函数递归<br>在一个函数内部，也可以调用函数本身。</p><p> import java.util.Scanner;</p><p> public class Main {</p><pre><code> private static int fib(int n) &#123;  // 求斐波那切数列第n项     if (n &lt;= 2) return 1;     return fib(n - 1) + fib(n - 2); &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(fib(n));</code></pre><p> }<br> }</p></li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>一个java文件只能有一个<strong>public</strong> class 类名，<strong>而且这个类名必须要与文件名相同</strong>，要定义其他类，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class student&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样定义。</p><p>每个源文件中，先写package（可以理解为路径），然后再写import，再定义类。</p><p>类有以下几种定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public (int):所有对象都可以访问。</span><br><span class="line">private (int)：只有在类之中才能访问，类之外不能访问。这样设计是为了在协作当中防止其他程序员对类中固定变量修改。</span><br><span class="line">protected (int)：同一个包或者子类可以访问。</span><br><span class="line">不添加修饰符：在同一个包内可以访问，就是package中（同一个文件夹下）所有类可以访问。</span><br><span class="line">public static (int):这个修饰的变量是指，这个类定义的所有对象共同享有，只有一个；与public int 的区别就在于 public int 是每个人各自享有，是独立的</span><br><span class="line">比如：</span><br><span class="line">class Student&#123;</span><br><span class="line">  public class int x=-1;</span><br><span class="line">  public int y=-1;</span><br><span class="line">&#125;</span><br><span class="line">public class Main&#123;</span><br><span class="line">public  static void main(String[] args)&#123;</span><br><span class="line">Student stu1 = new Student(), stu2 = new Student(), stu3 = new Student();</span><br><span class="line">//x就像是黑板，被stu1,stu2,stu3共同享有；y就像是课本，每个人都有各自的；</span><br><span class="line">Student.x=2;</span><br><span class="line">System.out.printf(&quot;%d % %d&quot;,stu1.x,stu2.x,stu3.x);//输出三个2，会全都修改掉，因为共享</span><br><span class="line">//student1.y=2;</span><br><span class="line">//System.out.printf(&quot;%d % %d&quot;,stu1.y,stu2.y,stu3.y);输出一个2 两个-1，只会修改掉单独的。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述讲的是成员变量和普通变量的关系。其实也就是成员函数（加 static）和普通函数的区别，加static，被类中所有对象共享；不加static，每个对象都是有独立的一份。静态函数只能调用（访问）成员变量；普通函数既能调用成员变量，也能调用普通变量；</p><p>在名字的目录下建立一个包Point，在包下面建立Point类，注意类都得首字母大写。然后我们一般会写这个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Point&#123;</span><br><span class="line">private int x;</span><br><span class="line">private int y;</span><br><span class="line">public Point(int x,int y)&#123;</span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y;//写这个方法是为了我们在创建对象的时候，访问到里面的成员变量；this.x的含义是这里有两个x，我们为了给成员变量x赋值，需要用到this.x;</span><br><span class="line">&#125;</span><br><span class="line">public int setX(int x)</span><br><span class="line">&#123;</span><br><span class="line">this.x = x;</span><br><span class="line">&#125;</span><br><span class="line">public int setY(int y)</span><br><span class="line">&#123;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">public void getX()&#123;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">public void getY()&#123;</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br><span class="line">public String toString()&#123;</span><br><span class="line">return String.format(&quot;(%d,%d)&quot;,x,y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Main方法中这样使用这个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point point = new Point(x,y);</span><br></pre></td></tr></table></figure><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>每个类只能继承一个类。</p><p>比如说我们上面写的那个Point是英雄的坐标，英雄会有颜色之类的，我们不用每个英雄都去写Point这个方法，只需要继承即可；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ColorPoint extends Point&#123;</span><br><span class="line">private String color;</span><br><span class="line">public ColorPoint(int x,int y,String color)&#123;</span><br><span class="line">super(x,y); //super(x,y)是继承父类中的Point()方法的，访问父类中的成员变量，需要用到super。</span><br><span class="line">this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">public void setColor(String color)&#123;</span><br><span class="line">this.color = color;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String toString()&#123;</span><br><span class="line">return String.format(&quot;%d %d %s&quot;,x,y,color);//会发现跟Point类当中的toString()同名，调用的时候会优先调用子类当中的，这就谈到了多态；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h3><p>多态有什么用呢，就比如说我们lol中不同的英雄，有不同的问候话，没有多态的话，就得写很多ifelse；有多态，可以HERO hero定义实例，然后去调用其内部的greet()函数。不懂得话，可以先看代码示例，再回来理解这段话。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point point = new Point(3, 4);</span><br><span class="line">        Point colorPoint = new ColorPoint(1, 2, &quot;red&quot;);//可以使用父类名字创建子类对象。</span><br><span class="line"></span><br><span class="line">        // 多态，同一个类的实例，调用相同的函数，运行结果不同</span><br><span class="line">        System.out.println(point.toString());</span><br><span class="line">        System.out.println(colorPoint.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>接口用来定义类当中需要包含的函数，接口中方法不包含修饰符的话，默认是public；类是实现接口的。接口可以规范我们需要去实现哪些功能；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Role&#123;</span><br><span class="line">void greet();</span><br><span class="line">int getSpeed();</span><br><span class="line">void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Hero&#123;</span><br><span class="line">void attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个接口可以继承多个接口,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Hero extends Role&#123;</span><br><span class="line">public void attack();//Hero接口也就有了像greet()、getSpeed()之类的函数了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类是实现接口的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Zeus implements Hero, Role &#123;</span><br><span class="line">    public final  String name=&quot;Zeus&quot;;</span><br><span class="line">    public void attack()&#123;</span><br><span class="line">        System.out.println(name+&quot;attack&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void greet() &#123;</span><br><span class="line">        System.out.println(name+&quot;HI&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(name+&quot;move&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSpeed() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Athena implements Role, Hero &#123;</span><br><span class="line">    public final  String name=&quot;Athena&quot;;</span><br><span class="line">    public void attack()&#123;</span><br><span class="line">        System.out.println(name+&quot;attack&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void greet() &#123;</span><br><span class="line">        System.out.println(name+&quot;HI&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(name+&quot;move&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSpeed() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Main方法中可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hero[] heros = &#123;</span><br><span class="line">                new Zeus(),new Athena(),</span><br><span class="line">        &#125;;//这种写数组以及遍历数组的方式记住了。</span><br><span class="line">        for (Hero hero:heros)&#123;</span><br><span class="line">            hero.greet();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>北京旅游小记</title>
      <link href="//e0624da7.html"/>
      <url>//e0624da7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Happy"><a href="#Happy" class="headerlink" title="Happy"></a>Happy</h2><p>北京旅游小记</p><div align='center'>  <img src='../images/1.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>二姐拍的太帅了哈哈哈</p></div><div align='center'>  <img src='../images/2.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>和三姐在恭王府</p></div><div align='center'>  <img src='../images/3.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>老妈在恭王府</p></div><div align='center'>  <img src='../images/4.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>二姐在恭王府</p></div><div align='center'>  <img src='../images/5.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>毛蛋第一次吃哭了</p></div><div align='center'>  <img src='../images/6.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>故宫实在太大了，整个被震撼住</p></div><p>观光车看的太开心了</p><div align='center'>  <img src='../images/7.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>大姐与彤彤在北京观光车上</p></div><div align='center'>  <img src='../images/8.jpg' width=450px>  <p align='center' style='font-size:20px;font-family:kaiti;color:red'>三姐老妈霖霖在观光车上 </p></div><p align='center'>     <iframe src="//player.bilibili.com/player.html?aid=395178570&bvid=BV1To4y1a74u&cid=1029590125&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习</title>
      <link href="//911ec8a4.html"/>
      <url>//911ec8a4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h1><p>先检查一下linu是否已经安装mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql start</span><br></pre></td></tr></table></figure><p>如果返回的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql: unrecognized service</span><br></pre></td></tr></table></figure><p>代表没有安装mysql，需要在线安装mysql。输入下面几行命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#安装 MySQL 服务端、核心程序</span><br><span class="line">sudo apt-get install mysql-server</span><br><span class="line"></span><br><span class="line">#安装 MySQL 客户端</span><br><span class="line">sudo apt-get install mysql-client</span><br></pre></td></tr></table></figure><p>在安装过程中会提示确认输入 YES，设置 root 用户密码（之后也可以修改）等，稍等片刻便可安装成功。</p><p>安装结束后，用命令验证是否安装并启动成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><p>如果提示有tcp信息，说明安装成功，可以使用下面的命令按照自己的需求对数据库进行配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><p>安装成功。</p><h1 id="数据库常用命令"><a href="#数据库常用命令" class="headerlink" title="数据库常用命令"></a>数据库常用命令</h1><h2 id="打开mysql"><a href="#打开mysql" class="headerlink" title="打开mysql"></a>打开mysql</h2><p>使用如下两条命令，打开 MySQL 服务并使用 root 用户登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql start</span><br><span class="line">mysql -u root   #会让你输入root密码，如果安装时没让您输入root密码的话，</span><br></pre></td></tr></table></figure><p>登陆成功，会显示welcome to the Mysql。</p><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><p>命令 <span style="color:red;font-size:文字大小;font-family:字体;"><strong>show databases；</strong></span>查看有哪些数据库，<strong>注意不要漏掉；</strong></p><h2 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h2><p>命令为<span style="color:red;font-size:文字大小;font-family:字体;"> <strong>use &lt;数据库名字&gt;</strong></span>，这里可以不用加分号，我们可以选择任意一个数据库，比如</p><h2 id="查看数据库-1"><a href="#查看数据库-1" class="headerlink" title="查看数据库"></a>查看数据库</h2><p>命令<span style="color:red;font-size:文字大小;font-family:字体;"> <strong>show tables;</strong></span> <strong>注意不要漏掉；</strong> 退出数据库可用 exit 或者 quit。</p><h1 id="数据库练习操作"><a href="#数据库练习操作" class="headerlink" title="数据库练习操作"></a>数据库练习操作</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>使用命令 <span style="color:red;font-size:文字大小;font-family:字体;"> <strong>create database <databasename>;</strong></span> 注意不漏掉分号，也不要给database加s。创建成功之后，可以使用命令 <span style="color:red;font-size:文字大小;font-family:字体;"> <strong>show databases;</strong></span> 查看已经建立好的数据库，在大多数系统中，sql语句不区分大小写。</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>使用命令 <span style="color:red;font-size:文字大小;font-family:字体;"> <strong>drop database <databasename>;</strong></span>。使用<span style="color:red;font-size:文字大小;font-family:字体;"> <strong>drop table <tablename>;</strong></span>删除数据库表</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>命令 <span style="color:red;font-size:文字大小;font-family:字体;"> <strong>use <databasename>;</strong></span> 显示database changed，则链接成功，可以使用show tables; 看数据库中有哪些表。</p><h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><p>数据表（<code>table</code>）简称表，它是数据库最重要的组成部分之一。数据库只是一个框架，表才是实质内容。</p><p>而一个数据库中一般会有多张表，这些各自独立的表通过建立关系被联接起来，才成为可以交叉查阅、一目了然的数据库。如下便是一张表：</p><div class="table-container"><table><thead><tr><th>ID</th><th>name</th><th>phone</th></tr></thead><tbody><tr><td>01</td><td>Tom</td><td>110110110</td></tr><tr><td>02</td><td>Jack</td><td>119119119</td></tr><tr><td>03</td><td>Rose</td><td>114114114</td></tr></tbody></table></div><h2 id="新建数据库表"><a href="#新建数据库表" class="headerlink" title="新建数据库表"></a>新建数据库表</h2><p>新建表语句格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE name(</span><br><span class="line">列名a 数据类型,</span><br><span class="line">列名b 数据类型，</span><br><span class="line">列名c 数据类型</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意不要忘记加分号（需要加分号的需要总结，可以看文章最后面）。</p><p>例子，比如在公司数据库中建立一个employee的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employee(</span><br><span class="line">id int(10),</span><br><span class="line">name char(20),</span><br><span class="line">phone int(12)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rename table 原名 to 新名；</span><br><span class="line">alter table 原名 rename 新名;</span><br><span class="line">alter table 原名 rename to 新名;</span><br></pre></td></tr></table></figure><p><span style="color:blue"><strong>注意不要忘记table</strong></span></p><h2 id="增加一列"><a href="#增加一列" class="headerlink" title="增加一列"></a>增加一列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add column 列名 数据类型 约束;</span><br><span class="line">alter table 表名 add 列名 数据类型 约束;</span><br></pre></td></tr></table></figure><p>新增加的列，默认放置在这张表的最右边。如果要把增加的列插入在指定位置，则需要在语句的最后使用 AFTER 关键词(<strong>“AFTER 列 1” 表示新增的列被放置在 “列 1” 的后面</strong>)。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table employee add weight int(4) default 120 after age;</span><br></pre></td></tr></table></figure><p>上面的效果是把新增的列加在某位置的后面，如果想放在第一列的位置，则使用 <code>FIRST</code> 关键词，如语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table employee add test int(4) default 11 first; </span><br></pre></td></tr></table></figure><h2 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h2><p>删除表中的一列和刚才使用的新增一列的语句格式十分相似，只是把关键词 <code>ADD</code> 改为 <code>DROP</code> ，语句后面不需要有数据类型、约束或位置信息。具体语句格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table employee drop column 列名；</span><br><span class="line">alter table 表名 drop 列名；</span><br></pre></td></tr></table></figure><h2 id="重命名一列"><a href="#重命名一列" class="headerlink" title="重命名一列"></a>重命名一列</h2><p>这条语句其实不只可用于重命名一列，准确地说，它是对一个列做修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 原列名 新列名 数据类型 约束;</span><br></pre></td></tr></table></figure><p><strong>这条重命名语句后面的 “数据类型” 不能省略，否则重命名失败。</strong></p><p>当<strong>原列名</strong>和<strong>新列名</strong>相同的时候，指定新的<strong>数据类型</strong>或<strong>约束</strong>，就可以用于修改数据类型或约束。需要注意的是，修改数据类型可能会导致数据丢失，所以要慎重使用。</p><h2 id="改变数据类型"><a href="#改变数据类型" class="headerlink" title="改变数据类型"></a>改变数据类型</h2><p>要修改一列的数据类型，除了使用刚才的 <strong>CHANGE</strong> 语句外，还可以用这样的 <strong>MODIFY</strong> 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名字 modify 列名字 数据类型；</span><br></pre></td></tr></table></figure><h2 id="修改表中某个值"><a href="#修改表中某个值" class="headerlink" title="修改表中某个值"></a>修改表中某个值</h2><p>大多数时候我们需要做修改的不会是整个数据库或整张表，而是表中的某一个或几个数据，这就需要我们用下面这条命令达到精确的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名字 set 列1=值1，列2=值2 where 条件；</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update employee set age=21,salary=3000 where name=&#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure><h2 id="删除表中某一行"><a href="#删除表中某一行" class="headerlink" title="删除表中某一行"></a>删除表中某一行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 条件;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据库中常用的数据类型可以见下表：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>大小(字节)</th><th>用途</th><th>格式</th></tr></thead><tbody><tr><td>INT</td><td>4</td><td>整数</td><td></td></tr><tr><td>FLOAT</td><td>4</td><td>单精度浮点数</td><td></td></tr><tr><td>DOUBLE</td><td>8</td><td>双精度浮点数</td><td></td></tr><tr><td>ENUM</td><td>—</td><td>单选,比如性别</td><td>ENUM(‘a’,’b’,’c’)</td></tr><tr><td>SET</td><td>—</td><td>多选</td><td>SET(‘1’,’2’,’3’)</td></tr><tr><td>DATE</td><td>3</td><td>日期</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3</td><td>时间点或持续时间</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1</td><td>年份值</td><td>YYYY</td></tr><tr><td>CHAR</td><td>0~255</td><td>定长字符串</td><td></td></tr><tr><td>VARCHAR</td><td>0~255</td><td>变长字符串</td><td></td></tr><tr><td>TEXT</td><td>0~65535</td><td>长文本数据</td></tr></tbody></table></div><p><strong>CHAR 和 VARCHAR 的区别:</strong> CHAR 的长度是固定的，而 VARCHAR 的长度是可以变化的，比如，存储字符串 “abc”，对于 CHAR(10)，表示存储的字符将占 10 个字节(包括 7 个空字符)，而同样的 VARCHAR(12) 则只占用 4 个字节的长度，<code>增加一个额外字节来存储字符串本身的长度</code>，12 只是最大值，当你存储的字符小于 12 时，按实际长度存储。</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>插入语句为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(列名a,列名b，列名c) VALUES(值1，值2，值3);</span><br><span class="line">比如向表employee中插入三个人的数据：</span><br><span class="line">INSERT INTO employee(id,name,phone) VALUES(123,&#x27;TOM&#x27;,245);</span><br><span class="line">INSERT INTO employee(id,name,phone) VALUES(133,&#x27;Jacky&#x27;,235);</span><br><span class="line">INSERT INTO employee(id,name) VALUES(143,&#x27;Bob&#x27;);</span><br></pre></td></tr></table></figure><p>注意有些数据类型在插入的时候需要用单引号括起来，比如Tom Jacky Bob,因为他们的数据类型是char，类似的数据类型有VARCHAR,ENUM,TEXT,DATE,TIME等。</p><p>对于第三个语句，其phone的值为null。<strong>并且注意挨着括号的不能有逗号。</strong></p><p>插入完成之后可以使用  <span style="color:red;font-size:文字大小;font-family:字体;"> select * from employee; </span>命令查看一下插入是否成功。</p><h2 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h2><p>在数据库操作语句中，使用最频繁，也被认为最重要的是 SELECT 查询语句。之前的实验中，我们已经在不少地方用到了 <code>SELECT * FROM table_name;</code> 这条语句用于查看一张表中的所有内容。 而 SELECT 与各种限制条件关键词搭配使用，具有各种丰富的功能。</p><p>select语句的基本格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的列名 from 表名 where 限制条件;</span><br></pre></td></tr></table></figure><p>若要查询表中的所有内容，将要查询的列名换成 * 用来代表所有列，若只需要查找指定的列的话，可以这样用(<span style="color:blue">两个列之间用逗号隔开)</span>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,gender from student;</span><br></pre></td></tr></table></figure><p>SELECT 语句常常会有 WHERE 限制条件，用于达到更加精确的查询。WHERE 限制条件可以有数学符号 (<code>=,&lt;,&gt;,&gt;=,&lt;=</code>) ，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age from employee where age&gt;25;#在employee表中查找出年龄大于25岁的人的名字以及年龄。</span><br></pre></td></tr></table></figure><p>从这两个单词就能够理解它们的作用。WHERE 后面可以有不止一条限制，而根据条件之间的逻辑关系，可以用 [<code>条件一 OR 条件二</code>] 和 [<code>条件一 AND 条件二</code>] 连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name,age from employee where age&lt;25 or age&gt;30;</span><br><span class="line">select name,age from employee where age&gt;25 and age&lt;30;(where age between 25 and 30)</span><br></pre></td></tr></table></figure><p>关键词 <strong>IN</strong> 和 <strong>NOT IN</strong> 的作用和它们的名字一样明显，用于筛选<strong>“在”</strong>或<strong>“不在”</strong>某个范围内的结果。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,age,phone,in_dpt FROM employee WHERE in_dpt IN (&#x27;dpt3&#x27;,&#x27;dpt4&#x27;);#查找出在公寓3和公寓4人的信息。</span><br></pre></td></tr></table></figure><p>关键字 <strong>LIKE</strong> 可用于实现模糊查询，常见于搜索功能中。</p><p>和 LIKE 联用的通常还有通配符，代表未知字符。SQL 中的通配符是 <code>_</code> 和 <code>%</code> 。其中 <code>_</code> 代表一个未指定字符，<code>%</code> 代表<strong>不定个</strong>未指定字符</p><p>比如，要只记得电话号码前四位数为 1101，而后两位忘记了，则可以用两个 <code>_</code> 通配符代替：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age,phone from employee where phone like &#x27;1101__&#x27;;</span><br></pre></td></tr></table></figure><p>另一种情况，比如只记名字的首字母，又不知道名字长度，则用 <code>%</code> 通配符代替不定个字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age,phone from employee where name like &#x27;J%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就查出了名字字母为J的人了。</p><p>为了使查询结果看起来更顺眼，我们可能需要对结果按某一列来排序，这就要用到 <strong>ORDER BY</strong> 排序关键词。默认情况下，<strong>ORDER BY</strong> 的结果是<strong>升序</strong>排列，而使用关键词 <strong>ASC</strong> 和 <strong>DESC</strong> 可指定<strong>升序</strong>或<strong>降序</strong>排序。 比如，我们<strong>按 salary 降序排列</strong>，SQL 语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age,phone,salary from employee order by salary asc(desc); </span><br></pre></td></tr></table></figure><p>SQL 允许对表中的数据进行计算。对此，SQL 有 5 个内置函数，这些函数都对 SELECT 的结果做操作：</p><div class="table-container"><table><thead><tr><th>函数名：</th><th>COUNT</th><th>SUM</th><th>AVG</th><th>MAX</th><th>MIN</th></tr></thead><tbody><tr><td>作用：</td><td>计数</td><td>求和</td><td>求平均值</td><td>最大值</td><td>最小值</td></tr></tbody></table></div><blockquote><p>其中 COUNT 函数可用于任何数据类型(因为它只是计数)，而 SUM 、AVG 函数都只能对数字类数据类型做计算，MAX 和 MIN 可用于数值、字符串或是日期时间数据类型。</p></blockquote><p>具体举例，比如计算出 salary 的最大、最小值，用这样的一条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(salary) as max_salary,min(salary) as min_salary from employee;</span><br></pre></td></tr></table></figure><p><img src="../../images/stuMysql/image-20230306101710744.png" alt="image-20230306101710744"></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>上面讨论的 SELECT 语句都仅涉及一个表中的数据，然而有时必须处理多个表才能获得所需的信息。例如：想要知道名为 “Tom” 的员工所在部门做了几个工程。员工信息储存在 employee 表中，但工程信息储存在 project 表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select of_dpt,count(proj_name) as count_project from project group by of_dpt having of_dpt in (select in_dpt from emplyee where name=&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure><p>上面代码包含两个 SELECT 语句，第二个 SELECT 语句将返回一个集合的数据形式，然后被第一个 SELECT 语句用 <strong>in</strong> 进行判断。</p><p>HAVING 关键字可以的作用和 WHERE 是一样的，都是说明接下来要进行条件筛选操作。区别在于 HAVING 用于对分组后的数据进行筛选。</p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>在处理多个表时，子查询只有在结果来自一个表时才有用。但如果需要显示两个表或多个表中的数据，这时就必须使用连接 <strong>(join)</strong> 操作。 连接的基本思想是把两个或多个表当作一个新的表来操作，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,people_num from employee,department where employee.int_dpt = department.dpt_name oder by id;</span><br></pre></td></tr></table></figure><p>这条语句查询出的是，各员工所在部门的人数，其中员工的 id 和 name 来自 employee 表，people_num 来自 department 表：</p><p>另一个连接语句格式是使用 JOIN ON 语法，刚才的语句等同于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name,people_num FROM employee JOIN department ON employee.in_dpt = department.dpt_name ORDER BY id;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, people_num, COUNT(proj_name) AS count_project</span><br><span class="line">  FROM employee, department, project</span><br><span class="line">  WHERE in_dpt = dpt_name AND of_dpt = dpt_name</span><br><span class="line">  GROUP BY name, people_num;</span><br></pre></td></tr></table></figure><p>前两行不必说了，从三张表选择三列数据；第三行设置三列数据的关系，<code>dpt_name</code> 是唯一值，<code>of_dpt</code> 和 <code>in_dpt</code> 的值必取自 <code>dpt_name</code> 这列，它们应该有外键关系，但不是必须的；第四行分组，分组不可或缺，否则会出现无意义的数据（一般来说连接查询语句中有 <code>COUNT</code> 就会有 <code>GROUP BY</code>），报一个 <code>sql_mode</code> 引起的错误，至于为什么选择 <code>name</code> 和 <code>people_num</code> 分组，大家可以试一下同时去掉 <code>COUNT</code> 和 <code>GROUP BY</code> 语句，看看其中的差异即可理解。</p><p>group by的意思就是给取集合。</p><p>比如，我们拥有下面这个 “Orders” 表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">O_Id</th><th style="text-align:left">OrderDate</th><th style="text-align:left">OrderPrice</th><th style="text-align:left">Customer</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">2008/12/29</td><td style="text-align:left">1000</td><td style="text-align:left">Bush</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">2008/11/23</td><td style="text-align:left">1600</td><td style="text-align:left">Carter</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">2008/10/05</td><td style="text-align:left">700</td><td style="text-align:left">Bush</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">2008/09/28</td><td style="text-align:left">300</td><td style="text-align:left">Bush</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">2008/08/06</td><td style="text-align:left">2000</td><td style="text-align:left">Adams</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">2008/07/21</td><td style="text-align:left">100</td><td style="text-align:left">Carter</td></tr></tbody></table></div><p>现在，我们希望查找每个客户的总金额（总订单）。</p><p>我们想要使用 GROUP BY 语句对客户进行组合。</p><p>我们使用下列 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Customer,SUM(OrderPrice) FROM Orders</span><br><span class="line">GROUP BY Customer</span><br></pre></td></tr></table></figure><p>结果集类似这样：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Customer</th><th style="text-align:left">SUM(OrderPrice)</th></tr></thead><tbody><tr><td style="text-align:left">Bush</td><td style="text-align:left">2000</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">1700</td></tr><tr><td style="text-align:left">Adams</td><td style="text-align:left">2000</td></tr></tbody></table></div><p>很棒吧，对不对？</p><p>让我们看一下如果省略 GROUP BY 会出现什么情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Customer,SUM(OrderPrice) FROM Orders</span><br></pre></td></tr></table></figure><p>结果集类似这样：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Customer</th><th style="text-align:left">SUM(OrderPrice)</th></tr></thead><tbody><tr><td style="text-align:left">Bush</td><td style="text-align:left">5700</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">5700</td></tr><tr><td style="text-align:left">Bush</td><td style="text-align:left">5700</td></tr><tr><td style="text-align:left">Bush</td><td style="text-align:left">5700</td></tr><tr><td style="text-align:left">Adams</td><td style="text-align:left">5700</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">5700</td></tr></tbody></table></div><p>上面的结果集不是我们需要的。</p><h1 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h1><p>约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。</p><p>比如规定一个用户的用户名不能为空值且没有重复记录，这就是一种约束规则。</p><p>在mysql中，有以下几种约束：</p><div class="table-container"><table><thead><tr><th>约束类型：</th><th>主键</th><th>默认值</th><th>唯一</th><th>外键</th><th>非空</th></tr></thead><tbody><tr><td>关键字：</td><td>PRIMARY KEY</td><td>DEFAULT</td><td>UNIQUE</td><td>FOREIGN KEY</td><td>NOT NULL</td></tr></tbody></table></div><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>在数据库中，如果有两行记录数据完全一样，那么如何来区分呢？ 答案是无法区分，如果有两行记录完全相同，那么对于 Mysql 就会认定它们是同一个实体，这与现实生活是存在差别的。</p><p>假如我们要存储一个学生的信息，信息包含姓名，身高，性别，年龄。</p><p>不幸的是有两个女孩都叫小梦，且她们的身高和年龄相同，数据库将无法区分这两个实体，这时就需要用到主键了。</p><p>主键（PRIMARY KEY）作为数据表中一行数据的唯一标识符，在一张表中通过主键就能准确定位到某一行数据，因此主键十分重要，它不能有重复记录且不能为空。定义主键的方式有如下几种：</p><div align='center'>  <img src='../images/22.png' width=450px>  <p align='center' style='font-size:15px;font-family:kaiti;color:red'></p></div><div align='center'>  <img src='../images/33.png' width=450px>  <p align='center' style='font-size:15px;font-family:kaiti;color:red'></p></div><p>还有一种复合主键，意思是可以通过表中的两列或者多列共同标识。</p><div align='center'>  <img src='../images/11.png' width=450px>  <p align='center' style='font-size:15px;font-family:kaiti;color:red'></p></div><h2 id="默认约束-DEFAULT"><a href="#默认约束-DEFAULT" class="headerlink" title="默认约束(DEFAULT)"></a>默认约束(DEFAULT)</h2><p>默认值约束 (DEFAULT) 规定，当有 DEFAULT 约束的列，插入数据为空时，将使用默认值。</p><p>默认值常用于一些可有可无的字段，比如用户的个性签名，如果用户没有设置，系统给他应该设定一个默认的文本，比如空文本或我们常见的 ‘这个人太懒了，没有留下任何信息’。</p><p>DEFAULT约束只会在使用INSERT语句的时候体现出来。就是说当insert into tablename（）values（）时，当tablename（）中的参数有default约束并且insert时没有赋值的时候，这个位置就会被DEFAULT的值代替，上面练习的insert中的第三个语句就是。</p><p>下面这段代码包含了DEFAULT约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">employee_info varchar(50) DEFAULT &#x27;这个人很懒，什么也没写&#x27;，</span><br></pre></td></tr></table></figure><h2 id="唯一约束（UNIQUE）"><a href="#唯一约束（UNIQUE）" class="headerlink" title="唯一约束（UNIQUE）"></a>唯一约束（UNIQUE）</h2><p>唯一约束，顾名思义，就是说这个表中的这一列的值不能有重复的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNIQUE(phone_num),</span><br></pre></td></tr></table></figure><p>当设置完table的时候，可以insert两个相同的值，验证一下unique是否生效。</p><h2 id="外键（FOREIGN-KEY）"><a href="#外键（FOREIGN-KEY）" class="headerlink" title="外键（FOREIGN KEY）"></a>外键（FOREIGN KEY）</h2><p>外键 (FOREIGN KEY) 既能确保数据完整性，也能表现表之间的关系。</p><p>比如，现在有用户表和文章表，给文章表中添加一个指向用户 id 的外键，表示这篇文章所属的用户 id，外键将确保这个外键指向的记录是存在的，如果你尝试删除一个用户，而这个用户还有文章存在于数据库中，那么操作将无法完成并报错。因为你删除了该用户过后，他发布的文章都没有所属用户了，而这样的情况是不被允许的。同理，你在创建一篇文章的时候也不能为它指定一个不存在的用户 id。</p><p><span style="color:red">一个表可以有多个外键，每个外键必须 REFERENCES (参考) 另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。</span></p><p>定义表的时候用下面语句定义外键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT (自定义外键名字) FOREIGN KEY(int_dpt) REFERENCES department(dpt_name) </span><br></pre></td></tr></table></figure><p>一般写在最下面。</p><h2 id="非空约束（NOT-NULL）"><a href="#非空约束（NOT-NULL）" class="headerlink" title="非空约束（NOT NULL）"></a>非空约束（NOT NULL）</h2><p>非空约束 (NOT NULL),听名字就能理解，被非空约束的列，在插入值时必须非空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salary int(10) NOT NULL,</span><br></pre></td></tr></table></figure><p>若插入违反非空约束的话，就会报错。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>可以尝试在Linux mysql中插入一个学生表。</p><p>现需要构建一个简易的成绩管理系统的数据库，来记录几门课程的学生成绩。数据库中有三张表分别用于记录学生信息、课程信息和成绩信息。</p><p>数据表结构如下：</p><p>学生表(student)：学生 id 、学生姓名和性别</p><p><img src="https://doc.shiyanlou.com/document-uid370051labid48timestamp1490234173345.png" alt="此处输入图片的描述"></p><p>课程表：课程 id 和课程名</p><p><img src="https://doc.shiyanlou.com/document-uid370051labid48timestamp1490234378903.png" alt="此处输入图片的描述"></p><p>成绩表：成绩 id 、学生 id 、课程 id 和分数</p><p><img src="https://doc.shiyanlou.com/document-uid370051labid48timestamp1490234181565.png" alt="此处输入图片的描述"></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>1.MySQL 服务处于运行状态</p><p>2.新建数据库的名称为 gradesystem</p><p>3.gradesystem 包含三个表：student、course、mark；</p><p>student 表包含 3 列：sid(主键)、sname、gender；</p><p>course 表包含 2 列：cid(主键)、cname；</p><p>mark 表包含 4 列：mid(主键)、sid、cid、score ，注意与其他两个表主键之间的关系。</p><p>4.将上述表中的数据分别插入到各个表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建一个数据库</span><br><span class="line">create database gradesystem;</span><br><span class="line">use database gradesystem;</span><br><span class="line">create table student(sid int(5) primary key,sname varchar(10),gender enum(&#x27;male&#x27;,&#x27;female&#x27;));</span><br><span class="line">create table course(cid int(5) primary key,cname varchar(10));</span><br><span class="line">create table mark(mid int(5),sid int(5),cid int(5),score int(5),primary key(mid),foreign key(sid) references student(sid),foreign key(cid) references course(cid));</span><br><span class="line">insert into student(sid,sname,gender) values(1,&#x27;Tom&#x27;,&#x27;male&#x27;) (2,&#x27;Jack&#x27;,&#x27;male&#x27;);</span><br></pre></td></tr></table></figure><h1 id="数据库的其他基本操作"><a href="#数据库的其他基本操作" class="headerlink" title="数据库的其他基本操作"></a>数据库的其他基本操作</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是一种与表有关的结构，它的作用相当于书的目录，可以根据目录中的页码快速找到所需的内容。</p><p>当表中有大量记录时，若要对表进行查询，没有索引的情况是全表搜索：将所有记录一一取出，和查询条件进行对比，然后返回满足条件的记录。这样做会执行大量磁盘 I/O 操作，并花费大量数据库系统时间。</p><p>而如果在表中已建立索引，在索引中找到符合查询条件的索引值，通过索引值就可以快速找到表中的数据，可以<strong>大大加快查询速度</strong>。这里就有关数据结构中的B树了。对一张表中的某个列建立索引，有以下两种语句格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add index 索引名（列名）;</span><br><span class="line">create index 索引名 on 表名（列名）</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table employee add index idx_id (id);</span><br><span class="line">create index idx_name on employee (name);</span><br></pre></td></tr></table></figure><p>索引的效果是加快查询速度，当表中数据不够多的时候是感受不出它的效果的。这里我们使用命令 <strong>SHOW INDEX FROM 表名字;</strong> 查看刚才新建的索引：</p><p>在使用 SELECT 语句查询的时候，语句中 WHERE 里面的条件，会<strong>自动判断有没有可用的索引</strong>。</p><p>比如有一个用户表，它拥有用户名(username)和个人签名(note)两个字段。其中用户名具有唯一性，并且格式具有较强的限制，我们给用户名加上一个唯一索引；个性签名格式多变，而且允许不同用户使用重复的签名，不加任何索引。</p><p>这时候，如果你要查找某一用户，使用语句 <code>select * from user where username=?</code> 和 <code>select * from user where note=?</code> 性能是有很大差距的，对<strong>建立了索引的用户名</strong>进行条件查询会比<strong>没有索引的个性签名</strong>条件查询快几倍，在数据量大的时候，这个差距只会更大。</p><p>一些字段不适合创建索引，比如性别，这个字段存在大量的重复记录无法享受索引带来的速度加成，甚至会拖累数据库，导致数据冗余和额外的 CPU 开销。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是从一个或多个表中导出来的表，是一种<strong>虚拟存在的表</strong>。它就像一个窗口，通过这个窗口可以看到系统专门提供的数据，这样，用户可以不用看到整个数据库中的数据，而只关心对自己有用的数据。</p><p>注意理解视图是虚拟的表：</p><ul><li>数据库中只存放了视图的定义，而没有存放视图中的数据，这些数据存放在原来的表中；</li><li>使用视图查询数据时，数据库系统会从原来的表中取出对应的数据；</li><li>视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变；</li><li>在使用视图的时候，可以把它当作一张表。</li></ul><p>创建视图的语句格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名（列a，列b，列c） as select 列1，列2，列3 from 表名字;</span><br></pre></td></tr></table></figure><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>导入一个纯数据文件，该文件中将包含与数据表字段相对应的多条数据，这样可以快速导入大量数据，除此之外，还有用 SQL 语句的导入方式，语法为：<code>source *.sql</code> 。两者之间的不同是：数据文件导入方式只包含数据，导入规则由数据库系统完成；SQL 文件导入相当于执行该文件中包含的 SQL 语句，可以实现多种操作，包括删除，更新，新增，甚至对数据库的重建。</p><p>数据文件导入，可以把一个文件里的数据保存进一张表。导入语句格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#x27;文件路径&#x27; into table 表名;</span><br></pre></td></tr></table></figure><p>由于导入导出大量数据都属于敏感操作，根据 mysql 的安全策略，导入导出的文件都必须在指定的路径下进行，就是要将你要导入数据的文件，放入到mysql-files这个文件夹中，才可以导入。<strong>注意要加table</strong> </p><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>导出与导入是相反的过程，是把数据库某个表中的数据保存到一个文件之中。导出语句基本格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列1，列2 into outfile &#x27;文件路径&#x27; from 表名;</span><br></pre></td></tr></table></figure><p><strong>注意：语句中 “文件路径” 之下不能已经有同名文件。不加table</strong></p><p><strong>对数据进行操作的不用加table关键字，对与表相关的就的必须加table。</strong></p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>数据库中的数据十分重要，出于安全性考虑，在数据库的使用中，应该注意使用备份功能。</p><blockquote><p>备份与导出的区别：导出的文件只是保存数据库中的数据；而备份，则是把数据库的结构，包括数据、约束、索引、视图等全部另存为一个文件。</p></blockquote><p><strong>mysqldump</strong> 是 MySQL 用于备份数据库的实用程序。它主要产生一个 SQL 脚本文件，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。</p><p>使用 mysqldump 备份的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot 数据库名&gt;备份文件名;</span><br><span class="line">mysqldump -uroot 数据库名 表名&gt;备份文件名;</span><br></pre></td></tr></table></figure><p>mysqldump 是一个备份工具，因此该命令是在终端中执行的，而不是在 mysql 交互环境下。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot test &lt; bak.sql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
